import pako from"pako";var max=1e13;class Int10{constructor(value){this.buf=[+value||0]}mulAdd(m,c){var i,t,b=this.buf,l=b.length;for(i=0;i<l;++i)(t=b[i]*m+c)<max?c=0:t-=(c=0|t/max)*max,b[i]=t;c>0&&(b[i]=c)}sub(c){var i,t,b=this.buf,l=b.length;for(i=0;i<l;++i)(t=b[i]-c)<0?(t+=max,c=1):c=0,b[i]=t;for(;0===b[b.length-1];)b.pop()}toString(base){if(10!=(base||10))throw"only base 10 is supported";for(var b=this.buf,s=b[b.length-1].toString(),i=b.length-2;i>=0;--i)s+=(max+b[i]).toString().substring(1);return s}valueOf(){for(var b=this.buf,v=0,i=b.length-1;i>=0;--i)v=v*max+b[i];return v}simplify(){var b=this.buf;return 1==b.length?b[0]:this}}const UNSUPPORTED_ALGORITHM='Unsupported algorithm name specified! Supported algorithms: "HS256", "HS384", "HS512", "RS256", "RS384", "RS512" and "none".',ILLEGAL_ARGUMENT="Illegal argument specified!",CRYPTO_NOT_FOUND="Could not find 'crypto'.",PAKO_NOT_FOUND="Could not find 'pako'.";function generateErrorMessage(value,callee,argumentName="argument",defaultType="string"){let message=`Invalid argument passed to ${callee}.`;return typeof value!==defaultType?message+=` Expected type '${defaultType}', received '${typeof value}'.`:value?"argument"!==argumentName&&(message+=` Provided ${argumentName} is invalid.`):message+=` Provided ${argumentName} is empty.`,message}function hex2AB(hex){if(!hex)throw new Error(ILLEGAL_ARGUMENT);const match=hex.match(/[0-9A-F]{2}/gi);if(!match)throw new Error(ILLEGAL_ARGUMENT);return new Uint8Array(match.map(i=>parseInt(i,16)))}const ellipsis="â€¦",reTimeS=/^(\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/,reTimeL=/^(\d\d\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/;function stringCut(str,len){return str.length>len&&(str=str.substring(0,len)+ellipsis),str}class Stream{constructor(enc,pos=0){this.hexDigits="0123456789ABCDEF",enc instanceof Stream?(this.enc=enc.enc,this.pos=enc.pos):(this.enc=enc,this.pos=pos)}get(pos){if(void 0===pos&&(pos=this.pos++),pos>=this.enc.length)throw"Requesting byte offset "+pos+" on a stream of length "+this.enc.length;return"string"==typeof this.enc?this.enc.charCodeAt(pos):this.enc[pos]}hexByte(b){return this.hexDigits.charAt(b>>4&15)+this.hexDigits.charAt(15&b)}hexDump(start,end,raw){for(var s="",i=start;i<end;++i)if(s+=this.hexByte(this.get(i)),!0!==raw)switch(15&i){case 7:s+="  ";break;case 15:s+="\n";break;default:s+=" "}return s}isASCII(start,end){for(var i=start;i<end;++i){var c=this.get(i);if(c<32||c>176)return!1}return!0}parseStringISO(start,end){for(var s="",i=start;i<end;++i)s+=String.fromCharCode(this.get(i));return s}parseStringUTF(start,end){for(var s="",i=start;i<end;){var c=this.get(i++);s+=c<128?String.fromCharCode(c):c>191&&c<224?String.fromCharCode((31&c)<<6|63&this.get(i++)):String.fromCharCode((15&c)<<12|(63&this.get(i++))<<6|63&this.get(i++))}return s}parseStringBMP(start,end){for(var hi,lo,str="",i=start;i<end;)hi=this.get(i++),lo=this.get(i++),str+=String.fromCharCode(hi<<8|lo);return str}parseTime(start,end,shortYear){var s=this.parseStringISO(start,end),m=(shortYear?reTimeS:reTimeL).exec(s);if(!m)return"Unrecognized time: "+s;if(shortYear){var y=+m[1]<70?2e3:1900;m[1]=y+""}return s=m[1]+"-"+m[2]+"-"+m[3]+" "+m[4],m[5]&&(s+=":"+m[5],m[6]&&(s+=":"+m[6],m[7]&&(s+="."+m[7]))),m[8]&&(s+=" UTC","Z"!=m[8]&&(s+=m[8],m[9]&&(s+=":"+m[9]))),s}parseInteger(start,end){for(var len,v=this.get(start),neg=v>127,pad=neg?255:0,s="";v==pad&&++start<end;)v=this.get(start);if(0===(len=end-start))return neg?-1:0;if(len>4){let t=+v;for(len<<=3;0==(128&(t^pad));)t<<=1,--len;s="("+len+" bit)\n"}neg&&(v-=256);const n=new Int10(v);for(let i=start+1;i<end;++i)n.mulAdd(256,this.get(i));return s+n.toString()}parseBitString(start,end,maxLength){for(var unusedBit=this.get(start),intro="("+((end-start-1<<3)-unusedBit)+" bit)\n",s="",i=start+1;i<end;++i){for(var b=this.get(i),skip=i==end-1?unusedBit:0,j=7;j>=skip;--j)s+=b>>j&1?"1":"0";if(s.length>maxLength)return intro+stringCut(s,maxLength)}return intro+s}parseOctetString(start,end,maxLength){if(this.isASCII(start,end))return stringCut(this.parseStringISO(start,end),maxLength);var len=end-start,s="("+len+" byte)\n";len>(maxLength/=2)&&(end=start+maxLength);for(var i=start;i<end;++i)s+=this.hexByte(this.get(i));return len>maxLength&&(s+=ellipsis),s}parseOID(start,end,maxLength){for(var s="",n=new Int10,bits=0,i=start;i<end;++i){var v=this.get(i);if(n.mulAdd(128,127&v),bits+=7,!(128&v)){if(""===s)if((n=n.simplify())instanceof Int10)n.sub(80),s="2."+n.toString();else{var m=n<80?n<40?0:1:2;s=m+"."+(n-40*m)}else s+="."+n.toString();if(s.length>maxLength)return stringCut(s,maxLength);n=new Int10,bits=0}}return bits>0&&(s+=".incomplete"),s}}class ASN1{constructor(stream,header,length,tag,sub){if(!(tag instanceof ASN1Tag))throw"Invalid tag value.";this.stream=stream,this.header=header,this.length=length,this.tag=tag,this.sub=sub}typeName(){switch(this.tag.tagClass){case 0:switch(this.tag.tagNumber){case 0:return"EOC";case 1:return"BOOLEAN";case 2:return"INTEGER";case 3:return"BIT_STRING";case 4:return"OCTET_STRING";case 5:return"NULL";case 6:return"OBJECT_IDENTIFIER";case 7:return"ObjectDescriptor";case 8:return"EXTERNAL";case 9:return"REAL";case 10:return"ENUMERATED";case 11:return"EMBEDDED_PDV";case 12:return"UTF8String";case 16:return"SEQUENCE";case 17:return"SET";case 18:return"NumericString";case 19:return"PrintableString";case 20:return"TeletexString";case 21:return"VideotexString";case 22:return"IA5String";case 23:return"UTCTime";case 24:return"GeneralizedTime";case 25:return"GraphicString";case 26:return"VisibleString";case 27:return"GeneralString";case 28:return"UniversalString";case 30:return"BMPString"}return"Universal_"+this.tag.tagNumber.toString();case 1:return"Application_"+this.tag.tagNumber.toString();case 2:return"["+this.tag.tagNumber.toString()+"]";case 3:return"Private_"+this.tag.tagNumber.toString()}}content(maxLength){if(void 0===this.tag)return null;void 0===maxLength&&(maxLength=1/0);var content=this.posContent(),len=Math.abs(this.length);if(!this.tag.isUniversal())return null!==this.sub?"("+this.sub.length+" elem)":this.stream.parseOctetString(content,content+len,maxLength);switch(this.tag.tagNumber){case 1:return 0===this.stream.get(content)?"false":"true";case 2:return this.stream.parseInteger(content,content+len);case 3:return this.sub?"("+this.sub.length+" elem)":this.stream.parseBitString(content,content+len,maxLength);case 4:return this.sub?"("+this.sub.length+" elem)":this.stream.parseOctetString(content,content+len,maxLength);case 6:return this.stream.parseOID(content,content+len,maxLength);case 16:case 17:return null!==this.sub?"("+this.sub.length+" elem)":"(no elem)";case 12:return stringCut(this.stream.parseStringUTF(content,content+len),maxLength);case 18:case 19:case 20:case 21:case 22:case 26:return stringCut(this.stream.parseStringISO(content,content+len),maxLength);case 30:return stringCut(this.stream.parseStringBMP(content,content+len),maxLength);case 23:case 24:return this.stream.parseTime(content,content+len,23==this.tag.tagNumber)}return null}toString(){return this.typeName()+"@"+this.stream.pos+"[header:"+this.header+",length:"+this.length+",sub:"+(null===this.sub?"null":this.sub.length)+"]"}posStart(){return this.stream.pos}posContent(){return this.stream.pos+this.header}posEnd(){return this.stream.pos+this.header+Math.abs(this.length)}toHexString(root){return this.stream.hexDump(this.posStart(),this.posEnd(),!0)}getHex(){return this.stream.hexDump(this.posContent(),this.posEnd(),!0)}getAB(clean=!0){return clean?function cleanZeros(b){return 0===b[0]?cleanZeros(b.slice(1)):b}(hex2AB(this.getHex())):hex2AB(this.getHex())}static decodeLength(stream){let buf=stream.get();const len=127&buf;if(len==buf)return len;if(len>6)throw"Length over 48 bits not supported at position "+(stream.pos-1);if(0===len)return null;buf=0;for(var i=0;i<len;++i)buf=256*buf+stream.get();return buf}static decode(stream){stream instanceof Stream||(stream=new Stream(stream,0));const streamStart=new Stream(stream),tag=new ASN1Tag(stream);let len=ASN1.decodeLength(stream),sub=null;const start=stream.pos,header=start-streamStart.pos,getSub=function(){if(sub=[],null!==len){for(var end=start+len;stream.pos<end;)sub[sub.length]=ASN1.decode(stream);if(stream.pos!=end)throw"Content size is not correct for container starting at offset "+start}else try{for(;;){const s=ASN1.decode(stream);if(s.tag.isEOC())break;sub[sub.length]=s}len=start-stream.pos}catch(e){throw"Exception while decoding undefined length content: "+e}};if(tag.tagConstructed)getSub();else if(tag.isUniversal()&&(3==tag.tagNumber||4==tag.tagNumber))try{if(3==tag.tagNumber&&0!=stream.get())throw"BIT STRINGs with unused bits cannot encapsulate.";getSub();for(var i=0;i<sub.length;++i)if(sub[i].tag.isEOC())throw"EOC is not supposed to be actual content."}catch(e){sub=null}if(null===sub){if(null===len)throw"We can't skip over an invalid tag with undefined length at offset "+start;stream.pos=start+Math.abs(len)}return new ASN1(streamStart,header,len,tag,sub)}}class ASN1Tag{constructor(stream){var buf=stream.get();if(this.tagClass=buf>>6,this.tagConstructed=0!=(32&buf),this.tagNumber=31&buf,31==this.tagNumber){var n=new Int10;do{buf=stream.get(),n.mulAdd(128,127&buf)}while(128&buf);this.tagNumber=n.simplify()}}isUniversal(){return 0===this.tagClass}isEOC(){return 0===this.tagClass&&0===this.tagNumber}}const webCrypto="object"==typeof window&&(window.crypto||window.msCrypto),webCryptoSubtle=webCrypto&&(webCrypto.subtle||webCrypto.webkitSubtle||webCrypto.Subtle);class JwtSplit{constructor(str,callee="JwtSplit"){if("string"!=typeof str)throw new Error(generateErrorMessage(str,callee,"JWT string"));const jwtArr=str.split(".");if(3!==jwtArr.length)throw new Error(generateErrorMessage(str,callee,"JWT string"));const[header,payload,signature]=jwtArr;this.header=header,this.payload=payload,this.signature=signature}toString(){return this.header+"."+this.payload+"."+this.signature}}class JwtDecode{constructor(str,callee="JwtDecode"){if(this.header={},this.payload={},this.signature="","string"!=typeof str)throw new Error(generateErrorMessage(str,callee,"JWT string"));const jwtObj=jwtSplit(str,callee);jwtObj&&(this.header=jwtObj.header?s2J(bu2s(jwtObj.header)):{},this.payload=jwtObj.payload?isGzip(this.header)?s2J(zbu2s(jwtObj.payload)):s2J(bu2s(jwtObj.payload)):{},this.signature=jwtObj.signature||"")}toString(){return s2bu(J2s(this.header))+"."+(isGzip(this.header)?s2zbu(J2s(this.payload)):s2bu(J2s(this.payload)))+"."+this.signature}}function tryPromise(fn){try{return Promise.resolve(fn())}catch(e){return Promise.reject(e)}}function s2J(str){try{return JSON.parse(str)}catch(e){throw new Error(e.message)}}function J2s(obj){try{return JSON.stringify(obj)}catch(e){throw new Error(e.message)}}function b2s(str){try{if("object"==typeof window&&"function"==typeof window.atob)return window.atob(str);if("undefined"!=typeof Buffer)return Buffer.from(str,"base64").toString("binary");throw new Error(ILLEGAL_ARGUMENT)}catch(e){throw new Error(e)}}function b2bu(str){if("string"!=typeof str||str.length%4!=0)throw new Error(ILLEGAL_ARGUMENT);return str.replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function bu2b(str){if("string"!=typeof str||str.length%4==1)throw new Error(ILLEGAL_ARGUMENT);for(;str.length%4!=0;)str+="=";return str.replace(/\-/g,"+").replace(/_/g,"/")}function bu2s(str){return b2s(bu2b(str))}function isGzip(header){return"object"==typeof header&&"string"==typeof header.zip&&"GZIP"===header.zip.toUpperCase()}function jwtDecode(str,callee="jwtDecode"){return new JwtDecode(str,callee)}function jwtSplit(str,callee="jwtSplit"){return new JwtSplit(str,callee)}const splitJwt=jwtSplit;function s2b(str){try{if("object"==typeof window&&"function"==typeof window.atob)return window.btoa(str);if("undefined"!=typeof Buffer)return Buffer.from(str).toString("base64");throw new Error(ILLEGAL_ARGUMENT)}catch(e){throw new Error(e)}}function s2bu(str){return b2bu(s2b(str))}function s2zbu(str){return s2bu(zip(str))}function unzip(str){if("string"!=typeof str)throw new Error(ILLEGAL_ARGUMENT);if(pako&&pako.inflate)return pako.inflate(str,{raw:!1,from:"string",to:"string"});throw new Error(PAKO_NOT_FOUND)}function zbu2s(str){return unzip(bu2s(str))}function zip(str){if("string"!=typeof str)throw new Error(ILLEGAL_ARGUMENT);if(pako&&pako.deflate)return pako.deflate(str,{raw:!1,from:"string",to:"string"});throw new Error(PAKO_NOT_FOUND)}function s2AB(str){const buff=new Uint8Array(str.length);for(let i=0;i<str.length;i++)buff[i]=str.charCodeAt(i);return buff}function AB2s(buff){return buff instanceof ArrayBuffer&&(buff=new Uint8Array(buff)),String.fromCharCode.apply(String,Array.from(buff))}async function createHmac(name,secret){if(webCryptoSubtle){const keyData=s2AB(secret);return await webCryptoSubtle.importKey("raw",keyData,{name:"HMAC",hash:{name:name}},!0,["sign"]).then(key=>({update:async function(thing){return await webCryptoSubtle.sign("HMAC",key,s2AB(thing))}}))}{const crypto=await import("crypto");return crypto&&crypto.createHmac?Promise.resolve(crypto.createHmac(name.replace("SHA-","sha"),secret)):Promise.reject(webCrypto)}}function algHSsign(bits){return async function(thing,secret){const hmac=await createHmac("SHA-"+bits,secret);return Promise.resolve(webCryptoSubtle?s2bu(AB2s(hmac&&await hmac.update(thing))):b2bu(hmac&&hmac.update(thing).digest("base64")))}}function algHSverify(bits){return async function(thing,signature,secret){return await algHSsign(bits)(thing,secret)===signature}}function s2pem(secret){if("string"!=typeof secret)throw new Error(ILLEGAL_ARGUMENT);let type="public";const lines=secret.split("\n"),ignoreLinesPriv=["-BEGIN RSA PRIVATE KEY-","-END RSA PRIVATE KEY-"],ignoreLinesPub=["-BEGIN RSA PUBLIC KEY-","-BEGIN PUBLIC KEY-","-END PUBLIC KEY-","-END RSA PUBLIC KEY-"],body=lines.map(line=>line.trim()).filter(line=>line.length&&function(line){return ignoreLinesPriv.some(ign=>line.toUpperCase().indexOf(ign)>-1)?(type="private",!1):!ignoreLinesPub.some(ign=>line.toUpperCase().indexOf(ign)>-1)}(line)).join("");if(body.length)return{body:s2AB(b2s(bu2b(body))),type:type};throw new Error(ILLEGAL_ARGUMENT)}class Asn1Tag{constructor(stream){this.tagClass=0,this.tagConstructed=!1,this.tagNumber=0;const buf=stream.read();this.tagClass=buf>>6,this.tagConstructed=0!=(32&buf),this.tagNumber=31&buf}}function pem2asn1(buff){if(!buff)throw new Error(ILLEGAL_ARGUMENT);buff instanceof ArrayBuffer&&(buff=new Uint8Array(buff));let asn1=ASN1.decode(buff),res={};if(3===asn1.sub.length&&(asn1=asn1.sub[2].sub[0]),9===asn1.sub.length?(res.modulus=asn1.sub[1].getAB(),res.publicExponent=parseInt(asn1.sub[2].getHex(),16),res.privateExponent=asn1.sub[3].getAB(),res.prime1=asn1.sub[4].getAB(),res.prime2=asn1.sub[5].getAB(),res.exponent1=asn1.sub[6].getAB(),res.exponent2=asn1.sub[7].getAB(),res.coefficient=asn1.sub[8].getAB()):2===asn1.sub.length&&(asn1=asn1.sub[1].sub[0],res.modulus=asn1.sub[0].getAB(),res.publicExponent=parseInt(asn1.sub[1].getHex(),16)),res.bits=8*(res.modulus.length-1)+Math.ceil(Math.log(res.modulus[0]+1)/Math.log(2)),!res.bits)throw new Error(ILLEGAL_ARGUMENT);return res}function asn12jwk(asn1,type,extra){if(!asn1)throw new Error(ILLEGAL_ARGUMENT);if("private"===(type="string"==typeof type&&type.toLowerCase()||["public","private"][asn1.privateExponent?1:0])&&!asn1.privateExponent)throw new Error(ILLEGAL_ARGUMENT);let v=asn1.publicExponent;const expSize=Math.ceil(Math.log(v)/Math.log(256)),exp=new Uint8Array(expSize).map((function(el){return el=v%256,v=Math.floor(v/256),el})).reverse();let jwk=Object.assign({kty:"RSA"},extra,{n:s2bu(AB2s(asn1.modulus)),e:s2bu(AB2s(exp))});return"private"===type&&Object.assign(jwk,{d:s2bu(AB2s(asn1.privateExponent)),p:s2bu(AB2s(asn1.prime1)),q:s2bu(AB2s(asn1.prime2)),dp:s2bu(AB2s(asn1.exponent1)),dq:s2bu(AB2s(asn1.exponent2)),qi:s2bu(AB2s(asn1.coefficient))}),jwk}function pem2jwk(secret,type,extra){return tryPromise(()=>{return asn12jwk(pem2asn1(s2pem(secret).body),type,extra)})}async function createSign(name){if(webCryptoSubtle)return{update:function(thing){return{sign:async function(secret,encoding){return await pem2jwk(secret,"private",{key_ops:["sign"],alg:name.replace("SHA-","RS")}).then(async keyData=>await webCryptoSubtle.importKey("jwk",keyData,{name:"RSASSA-PKCS1-v1_5",hash:{name:name}},!0,["sign"]).then(async key=>await webCryptoSubtle.sign({name:"RSASSA-PKCS1-v1_5",hash:{name:name}},key,s2AB(thing)).then(AB2s).then(s2b)))}}}};{const crypto=await import("crypto");if(crypto&&crypto.createSign)return crypto.createSign(name.replace("SHA-","RSA-SHA"));throw new Error(CRYPTO_NOT_FOUND)}}function algRSsign(bits){return async function(thing,privateKey){try{const res=await createSign("SHA-"+bits);return b2bu(await res.update(thing).sign(privateKey,"base64"))}catch(e){return Promise.reject(e)}}}async function createVerify(name){if(webCryptoSubtle)return{update:function(thing){return{verify:async function(secret,signature,encoding){return await pem2jwk(secret,"public",{key_ops:["verify"],alg:name.replace("SHA-","RS")}).then(async({kty:kty,n:n,e:e})=>await webCryptoSubtle.importKey("jwk",{kty:kty,n:n,e:e},{name:"RSASSA-PKCS1-v1_5",hash:{name:name}},!1,["verify"]).then(async key=>await webCryptoSubtle.verify("RSASSA-PKCS1-v1_5",key,s2AB(bu2s(signature)),s2AB(thing))))}}}};{const crypto=await import("crypto");if(crypto&&crypto.createVerify)return crypto.createVerify(name.replace("SHA-","RSA-SHA"));throw new Error(CRYPTO_NOT_FOUND)}}function algRSverify(bits){return async function(thing,signature,publicKey){try{signature=bu2b(signature);const rsaVerify=await createVerify("SHA-"+bits);return await rsaVerify.update(thing).verify(publicKey,signature,"base64")}catch(e){return Promise.reject(e)}}}async function algVerify(algorithm,thing,signature,secret){if("string"!=typeof algorithm||algorithm.length<4)throw new Error(UNSUPPORTED_ALGORITHM);const algo=algorithm.toLowerCase();if("none"===algo)return""===signature;const type=algo.slice(0,2),bits=parseInt(algo.slice(2));if(isNaN(bits)||[256,384,512].indexOf(bits)<0)throw new Error(UNSUPPORTED_ALGORITHM);switch(type){case"rs":return await algRSverify(bits)(thing,signature,secret);case"hs":return await algHSverify(bits)(thing,signature,secret);default:throw new Error(UNSUPPORTED_ALGORITHM)}}async function algSign(algorithm,thing,secret){if("string"!=typeof algorithm||algorithm.length<4)throw new Error(UNSUPPORTED_ALGORITHM);const algo=algorithm.toLowerCase();if("none"===algo)return"";const type=algo.slice(0,2),bits=parseInt(algo.slice(2));if(isNaN(bits)||[256,384,512].indexOf(bits)<0)throw new Error(UNSUPPORTED_ALGORITHM);switch(type){case"rs":return await algRSsign(bits)(thing,secret);case"hs":return await algHSsign(bits)(thing,secret);default:throw new Error(UNSUPPORTED_ALGORITHM)}}async function jwtVerify(jwtStr,secret){const jwt=jwtSplit(jwtStr,"jwtVerify"),header=s2J(bu2s(jwt.header)),thing=jwt.header+"."+jwt.payload;return tryPromise(()=>algVerify(header.alg,thing,jwt.signature,secret))}const verifyJwt=jwtVerify;function jwtSign(jwtStr,secret){const jwt=jwtSplit(jwtStr,"jwtSign"),header=s2J(bu2s(jwt.header)),thing=jwt.header+"."+jwt.payload;return tryPromise(async()=>await algSign(header.alg,thing,secret))}const signJwt=jwtSign;async function jwtResign(jwtStr,secret,alg){const jwt=jwtDecode(jwtStr,"jwtResign");return alg&&(jwt.header.alg=alg),jwt.signature=await jwtSign(jwt.toString(),secret),jwt.toString()}const resignJwt=jwtResign;async function cryptoType(){const crypto=await import("crypto");return crypto?crypto.type||"crypto-node":"undefined"}export{AB2s,Asn1Tag,J2s,JwtDecode,JwtSplit,algHSsign,algHSverify,algRSsign,algRSverify,algSign,algVerify,asn12jwk,b2bu,b2s,bu2b,bu2s,createHmac,createSign,createVerify,cryptoType,isGzip,jwtDecode,jwtResign,jwtSign,jwtSplit,jwtVerify,pem2asn1,pem2jwk,resignJwt,s2AB,s2J,s2b,s2bu,s2pem,s2zbu,signJwt,splitJwt,tryPromise,unzip,verifyJwt,webCrypto,webCryptoSubtle,zbu2s,zip};
