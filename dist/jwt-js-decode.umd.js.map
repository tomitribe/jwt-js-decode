{"version":3,"file":"jwt-js-decode.umd.js","sources":["../src/jwt-js-decode.ts"],"sourcesContent":["import pako from \"pako\";\r\nconst crypto = require(\"crypto\");\r\n/*\r\nbrowserify\r\nimport { createHmac, createSign, createVerify } from \"crypto-browserify\";\r\n\r\nnode.js\r\nimport { createHmac, createSign, createVerify } from \"crypto\";\r\n*/\r\nexport const webCrypto = typeof window === \"object\" && (window.crypto || window['msCrypto']);\r\nexport const webCryptoSubtle = webCrypto && (webCrypto.subtle ||  webCrypto['webkitSubtle'] || webCrypto['Subtle']);\r\n\r\nexport const UNSUPPORTED_ALGORITHM = 'Unsupported algorithm name specified! Supported algorithms: \"HS256\", \"HS384\", \"HS512\", \"RS256\", \"RS384\", \"RS512\" and \"none\".';\r\nexport const ILLEGAL_ARGUMENT = 'Illegal argument specified!';\r\n\r\n\r\n/**\r\n * Pako 1.0.6 has 'from' property which is not included in current version of typeDef @types/pako@1.0.0\r\n *\r\n * @hidden\r\n */\r\ndeclare namespace Pako {\r\n    export interface DeflateOptions {\r\n        raw?: boolean;\r\n        from?: string;\r\n        to?: string;\r\n    }\r\n\r\n    export interface InflateOptions {\r\n        raw?: boolean;\r\n        from?: string;\r\n        to?: string;\r\n    }\r\n}\r\n\r\n/**\r\n * Class for creating a JwtSplit object with three parts of JWT Token as strings\r\n *\r\n * @class  JwtSplit\r\n */\r\nexport class JwtSplit {\r\n    /**\r\n     * Header (first) part of JWT Token\r\n     *\r\n     * @name  header\r\n     * @type {string}\r\n     */\r\n    header: string;\r\n\r\n    /**\r\n     * Payload (second) part of JWT Token\r\n     *\r\n     * @name  payload\r\n     * @type {string}\r\n     */\r\n    payload: string;\r\n\r\n    /**\r\n     * Signature (third) part of JWT Token\r\n     *\r\n     * @name  signature\r\n     * @type {string}\r\n     */\r\n    signature: string;\r\n\r\n    constructor(str: string) {\r\n        if (typeof str !== 'string') {\r\n            throw new Error(ILLEGAL_ARGUMENT);\r\n        }\r\n\r\n        const jwtArr = str.split('.');\r\n        if (jwtArr.length !== 3) {\r\n            throw new Error(ILLEGAL_ARGUMENT);\r\n        }\r\n\r\n        const [header, payload, signature] = jwtArr;\r\n        this.header = header;\r\n        this.payload = payload;\r\n        this.signature = signature;\r\n    }\r\n\r\n    public toString(): string {\r\n        return this.header + '.' + this.payload + '.' + this.signature\r\n    }\r\n}\r\n\r\n/** JwtPart interface basically object type definition used as a placeholder */\r\ninterface JwtPart {\r\n    [key: string]: any\r\n}\r\n\r\n/**\r\n * Class for creating a JwtDecode object with three parts of JWT Token, header and payload decoded and parsed, signature in initial form\r\n *\r\n * @class  JwtDecode\r\n */\r\nexport class JwtDecode {\r\n    /**\r\n     * Header (first) part of JWT Token\r\n     *\r\n     * @name  header\r\n     * @type {JwtPart}\r\n     */\r\n    public header: JwtPart = {};\r\n\r\n    /**\r\n     * Payload (second) part of JWT Token\r\n     *\r\n     * @name  payload\r\n     * @type {JwtPart}\r\n     */\r\n    public payload: JwtPart = {};\r\n\r\n    /**\r\n     * Signature (third) part of JWT Token\r\n     *\r\n     * @name  signature\r\n     * @type {string}\r\n     */\r\n    public signature: string = '';\r\n\r\n    constructor(str: string) {\r\n        if (typeof str !== 'string') {\r\n            throw new Error(ILLEGAL_ARGUMENT);\r\n        }\r\n        const jwtObj: JwtSplit = jwtSplit(str);\r\n        if (jwtObj) {\r\n            this.header = jwtObj.header ? s2J(bu2s(jwtObj.header)) : {};\r\n            this.payload = jwtObj.payload ? (isGzip(this.header) ? s2J(zbu2s(jwtObj.payload)) : s2J(bu2s(jwtObj.payload))) : {};\r\n            this.signature = jwtObj.signature || '';\r\n        }\r\n    }\r\n\r\n    public toString(): string {\r\n        return s2bu(JSON.stringify(this.header)) + '.' + (isGzip(this.header) ? s2zbu(JSON.stringify(this.payload)) : s2bu(JSON.stringify(this.payload))) + '.' + this.signature\r\n    }\r\n}\r\n/**\r\n * Converts string to base64 string\r\n *\r\n * @param {string} str - data string to convert\r\n *\r\n * @returns {string} decoded data string\r\n */\r\nexport function s2J(str: string): any {\r\n    try{\r\n        return JSON.parse(str);\r\n    } catch(e) {\r\n        throw new Error(ILLEGAL_ARGUMENT);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Converts string to base64 string\r\n *\r\n * @param {string} str - data string to convert\r\n *\r\n * @returns {string} decoded data string\r\n */\r\nexport function b2s(str: string): string {\r\n    try{\r\n        if(typeof window === 'object' && typeof window.atob === 'function') {\r\n            return window.atob(str);\r\n        } else if(typeof Buffer !== 'undefined') {\r\n            return new Buffer(str, 'base64').toString('binary')\r\n        } else throw new Error(ILLEGAL_ARGUMENT);\r\n    } catch(e) {\r\n        throw new Error(e);\r\n    }\r\n}\r\n\r\n/**\r\n * Converts base64 string to base64url string\r\n *\r\n * @param {string} str - data string to convert\r\n *\r\n * @returns {string} base64url string\r\n */\r\nexport function b2bu(str: string): string {\r\n    if ((typeof str !== 'string') || (str.length % 4 !== 0)) {\r\n        throw new Error(ILLEGAL_ARGUMENT);\r\n    }\r\n\r\n    return str\r\n        .replace(/\\+/g, '-')\r\n        .replace(/\\//g, '_')\r\n        .replace(/=/g, '');\r\n}\r\n\r\n/**\r\n *\r\n * Converts base64url string to base64 string\r\n *\r\n * @param {string} str - data string to convert\r\n *\r\n * @returns {string} base64 string\r\n */\r\nexport function bu2b(str: string): string {\r\n    if ((typeof str !== 'string') || (str.length % 4 === 1)) {\r\n        throw new Error(ILLEGAL_ARGUMENT);\r\n    }\r\n\r\n    for (; (str.length % 4 !== 0);) {\r\n        str += '=';\r\n    }\r\n    return str\r\n        .replace(/\\-/g, '+')\r\n        .replace(/_/g, '/');\r\n}\r\n\r\n/**\r\n * Converts base64url string to string\r\n *\r\n * @param {string} str - base64url string to convert\r\n *\r\n * @returns {string} decoded data string\r\n */\r\nexport function bu2s(str: string): string {\r\n    return b2s(bu2b(str));\r\n}\r\n\r\n/**\r\n * Check if header has zip property (and it is equal to 'GZIP', ignorecase)\r\n *\r\n * @param {string} header - object to check\r\n *\r\n * @returns {boolean} does it have gzip in zip property\r\n */\r\nexport function isGzip(header: JwtPart): boolean {\r\n    return typeof header === 'object' && typeof header.zip === 'string' && header.zip.toUpperCase() === 'GZIP'\r\n}\r\n\r\n/**\r\n * Decode jwtToken header and payload\r\n *\r\n * @param {string} str - data string to decode\r\n *\r\n * @returns {JwtDecode} object with decoded header and body, and signature untouched\r\n */\r\nexport function jwtDecode(str: string): JwtDecode {\r\n    return new JwtDecode(str);\r\n}\r\n\r\n/**\r\n * Split jwtToken into object {header, payload, signature}\r\n *\r\n * @param {string} str - data string to split\r\n *\r\n * @returns {JwtSplit} jwt split object of three strings\r\n */\r\nexport function jwtSplit(str: string): JwtSplit {\r\n    return new JwtSplit(str);\r\n}\r\n\r\n/**\r\n * Converts base64 string to string\r\n *\r\n * @param {string} str - data string to convert\r\n *\r\n * @returns {string} base64 string\r\n */\r\nexport function s2b(str: string): string {\r\n    try{\r\n        if(typeof window === 'object' && typeof window.atob === 'function') {\r\n            return window.btoa(str);\r\n        } else if(typeof Buffer !== 'undefined') {\r\n            return new Buffer(str).toString('base64');\r\n        } else throw new Error(ILLEGAL_ARGUMENT);\r\n    } catch(e) {\r\n        throw new Error(e);\r\n    }\r\n}\r\n\r\n/**\r\n * Converts string to base64url string\r\n *\r\n * @param {string} str - data string to convert\r\n *\r\n * @returns {string} base64url string\r\n */\r\nexport function s2bu(str: string): string {\r\n    return b2bu(s2b(str));\r\n}\r\n\r\n/**\r\n * Gzip and encode data string to base64url string\r\n *\r\n * @param {string} str - data string to encode\r\n *\r\n * @returns {string} base64url string\r\n */\r\nexport function s2zbu(str: string): string {\r\n    return s2bu(zip(str));\r\n}\r\n\r\n/**\r\n * Converts from gzip data string to string\r\n *\r\n * @param {string} str - data string to convert\r\n *\r\n * @returns {string} decoded data string\r\n */\r\nexport function unzip(str: string): string {\r\n    if (typeof str !== 'string') {\r\n        throw new Error(ILLEGAL_ARGUMENT);\r\n    }\r\n\r\n    return pako.inflate(str, {\r\n        raw: false,\r\n        from: 'string',\r\n        to: 'string'\r\n    } as Pako.InflateOptions & { to: 'string' });\r\n}\r\n\r\n/**\r\n * Decode from base64url and unzip data string\r\n *\r\n * @param {string} str - data string to decode\r\n *\r\n * @returns {string} decoded data string\r\n */\r\nexport function zbu2s(str: string): string {\r\n    return unzip(bu2s(str));\r\n}\r\n\r\n/**\r\n * Converts string to gzip data string\r\n *\r\n * @param {string} str - data string to convert\r\n *\r\n * @returns {string} gzip data string\r\n */\r\nexport function zip(str: string): string {\r\n    if (typeof str !== 'string') {\r\n        throw new Error(ILLEGAL_ARGUMENT);\r\n    }\r\n\r\n    return pako.deflate(str, {\r\n        raw: false,\r\n        from: 'string',\r\n        to: 'string'\r\n    } as Pako.DeflateOptions & { to: 'string' });\r\n}\r\n\r\n/**\r\n * Converts string to ArrayBuffer\r\n *\r\n * @param {string} str - data string to convert\r\n *\r\n * @returns {ArrayBuffer | Uint8Array} charCode ArrayBuffer\r\n */\r\nfunction s2AB(str: string): ArrayBuffer | Uint8Array {\r\n    const buff = new Uint8Array(str.length);\r\n    for (let i = 0; i < str.length; i++) buff[i] = str.charCodeAt(i);\r\n    return buff;\r\n}\r\n\r\n/**\r\n * Converts ArrayBuffer to string\r\n *\r\n * @param {ArrayBuffer | Uint8Array} buff - charCode ArrayBuffer to convert\r\n *\r\n * @returns {string} data string\r\n */\r\nfunction AB2s(buff: ArrayBuffer | Uint8Array): string {\r\n    if (buff instanceof ArrayBuffer) buff = new Uint8Array(buff);\r\n    return String.fromCharCode.apply(String, buff);\r\n}\r\n\r\n/*\r\nexport function algHSsign(bits: number) {\r\n    return function sign(thing: string, secret: string): string {\r\n        const hmac = createHmac('sha' + bits, secret);\r\n        return b2bu(hmac.update(thing).digest('base64'));\r\n    }\r\n}\r\n\r\nexport function algHSverify(bits: number) {\r\n    return function verify(thing: string, signature: string, secret: string): boolean {\r\n        return signature === algHSsign(bits)(thing, secret);\r\n    }\r\n}\r\n\r\nexport function algRSsign(bits: number) {\r\n    return function sign(thing: string, privateKey: string): string {\r\n        const rsaSign = createSign('RSA-SHA' + bits);\r\n        return b2bu(rsaSign.update(thing).sign(privateKey, 'base64'));\r\n    }\r\n}\r\n\r\nexport function algRSverify(bits: number) {\r\n    return function verify(thing: string, signature: string, publicKey: string): boolean {\r\n        signature = bu2b(signature);\r\n        const rsaVerify = createVerify('RSA-SHA' + bits);\r\n        rsaVerify.update(thing);\r\n        return rsaVerify.verify(publicKey, signature, 'base64');\r\n    }\r\n}*/\r\n\r\n/**\r\n * Async function inspired by createHmac in crypto (used WebCrypto Api supported by most browsers)\r\n *\r\n */\r\n\r\nexport async function createHmac(name: string, secret: string): Promise<any> {\r\n    if (webCryptoSubtle) {\r\n        const keyData = s2AB(secret);\r\n        return await webCryptoSubtle.importKey(\r\n            'raw',\r\n            keyData,\r\n            { name: 'HMAC', hash: { name: name } },\r\n            true,\r\n            ['sign']\r\n        ).then(key => {\r\n            return {\r\n                _key: key,\r\n                update: async function (thing): Promise<ArrayBuffer> {\r\n                    return await webCryptoSubtle.sign(\r\n                        'HMAC',\r\n                        key,\r\n                        s2AB(thing)\r\n                    )\r\n                }\r\n            }\r\n        })\r\n    } else {\r\n        return !!crypto && crypto.createHmac ? Promise.resolve(crypto.createHmac(name.replace('SHA-', 'sha'), secret)) : Promise.reject(webCrypto);\r\n    }\r\n}\r\n\r\n/**\r\n * Algorithm HMAC sign generator\r\n *\r\n */\r\nexport function algHSsign(bits: number) {\r\n    /**\r\n     * Algorithm HMAC signer\r\n     *\r\n     */\r\n    return async function sign(thing: string, secret: string): Promise<string> {\r\n        const hmac = await createHmac('SHA-' + bits, secret);\r\n        return Promise.resolve(webCryptoSubtle ? s2bu(AB2s(hmac && await hmac.update(thing))) : b2bu(hmac && hmac.update(thing).digest('base64')));\r\n    }\r\n}\r\n\r\n/**\r\n * Algorithm HMAC verify generator\r\n *\r\n */\r\nexport function algHSverify(bits: number) {\r\n    /**\r\n     * Algorithm HMAC verifier\r\n     *\r\n     */\r\n    return async function verify(thing: string, signature: string, secret: string): Promise<boolean> {\r\n        return await algHSsign(bits)(thing, secret) === signature;\r\n    }\r\n}\r\n\r\n/*export function algRSsign(bits: number) {\r\n    return function sign(thing: string, privateKey: string): string {\r\n        const rsaSign = crypto.createSign('RSA-SHA' + bits);\r\n        return b2bu(rsaSign.update(thing).sign(privateKey, 'base64'));\r\n    }\r\n}\r\n\r\nexport function algRSverify(bits: number) {\r\n    return function verify(thing: string, signature: string, publicKey: string): boolean {\r\n        signature = bu2b(signature);\r\n        const rsaVerify = crypto.createVerify('RSA-SHA' + bits);\r\n        rsaVerify.update(thing);\r\n        return rsaVerify.verify(publicKey, signature, 'base64');\r\n    }\r\n}*/\r\n\r\n/**\r\n * Universal algorithm verifier\r\n *\r\n */\r\nexport async function algVerify(algorithm: string, thing: string, signature: string, secret: string): Promise<boolean> {\r\n    if (typeof algorithm !== 'string' || algorithm.length < 4) {\r\n        throw new Error(UNSUPPORTED_ALGORITHM);\r\n    }\r\n    const algo = algorithm.toLowerCase();\r\n\r\n    if (algo === 'none') {\r\n        return signature === '';\r\n    }\r\n\r\n    const type = algo.slice(0, 2), bits = parseInt(algo.slice(2));\r\n    if (isNaN(bits) || ([256, 384, 512].indexOf(bits) < 0)) {\r\n        throw new Error(UNSUPPORTED_ALGORITHM);\r\n    }\r\n\r\n    switch (type) {\r\n        //case 'rs':\r\n            //return await algRSverify(bits)(thing, signature, secret);\r\n        case 'hs':\r\n            return await algHSverify(bits)(thing, signature, secret);\r\n        default:\r\n            throw new Error(UNSUPPORTED_ALGORITHM);\r\n    }\r\n}\r\n\r\n/**\r\n * Universal algorithm signer\r\n *\r\n */\r\nexport async function algSign(algorithm: string, thing: string, secret: string): Promise<string> {\r\n    if (typeof algorithm !== 'string' || algorithm.length < 4) {\r\n        throw new Error(UNSUPPORTED_ALGORITHM);\r\n    }\r\n    const algo = algorithm.toLowerCase();\r\n\r\n    if (algo === 'none') {\r\n        return '';\r\n    }\r\n\r\n    const type = algo.slice(0, 2), bits = parseInt(algo.slice(2));\r\n    if (isNaN(bits) || ([256, 384, 512].indexOf(bits) < 0)) {\r\n        throw new Error(UNSUPPORTED_ALGORITHM);\r\n    }\r\n\r\n    switch (type) {\r\n        //case 'rs':\r\n            //return await algRSsign(bits)(thing, secret);\r\n        case 'hs':\r\n            return await algHSsign(bits)(thing, secret);\r\n        default:\r\n            throw new Error(UNSUPPORTED_ALGORITHM);\r\n    }\r\n}\r\n\r\nexport async function jwtVerify(jwtStr: string, secret: string): Promise<boolean> {\r\n    const jwt = jwtSplit(jwtStr),\r\n        header = s2J(bu2s(jwt.header)),\r\n        thing = jwt.header + '.' + jwt.payload;\r\n    return await algVerify(header.alg, thing, jwt.signature, secret);\r\n}\r\n\r\nexport async function jwtSign(jwtStr: string, secret: string): Promise<string> {\r\n    const jwt = jwtSplit(jwtStr),\r\n        header = s2J(bu2s(jwt.header)),\r\n        thing = jwt.header + '.' + jwt.payload;\r\n    return await algSign(header.alg, thing, secret);\r\n}\r\n\r\nexport async function resignJwt(jwtStr: string, secret: string): Promise<string> {\r\n    const jwt = jwtSplit(jwtStr),\r\n        header = s2J(bu2s(jwt.header)),\r\n        thing = jwt.header + '.' + jwt.payload;\r\n    return thing + '.' + await algSign(header.alg, thing, secret);\r\n}\r\n\r\n/**\r\n * Used for testing only\r\n *\r\n * @hidden\r\n */\r\nexport function cryptoType(): string {\r\n    return crypto ? crypto['type'] || 'crypto-node' : 'undefined';\r\n}\r\n\r\nconst jwsJsDecode = {\r\n    JwtDecode,\r\n    JwtSplit,\r\n    b2bu,\r\n    b2s,\r\n    bu2b,\r\n    bu2s,\r\n    isGzip,\r\n    jwtDecode,\r\n    jwtSplit,\r\n    s2b,\r\n    s2bu,\r\n    s2zbu,\r\n    unzip,\r\n    zbu2s,\r\n    zip,\r\n    algHSsign,\r\n    algHSverify,\r\n    //algRSsign,\r\n    //algRSverify,\r\n    algVerify,\r\n    algSign,\r\n    jwtVerify,\r\n    jwtSign,\r\n    resignJwt,\r\n    cryptoType\r\n};\r\n\r\nexport default jwsJsDecode;\r\n"],"names":[],"mappings":"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"}