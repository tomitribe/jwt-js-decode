var jwtJsDecode=function(exports){"use strict";function zero$1(buf){let len=buf.length;for(;--len>=0;)buf[len]=0}const extra_lbits=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),extra_dbits=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),extra_blbits=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),bl_order=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),static_ltree=new Array(576);zero$1(static_ltree);const static_dtree=new Array(60);zero$1(static_dtree);const _dist_code=new Array(512);zero$1(_dist_code);const _length_code=new Array(256);zero$1(_length_code);const base_length=new Array(29);zero$1(base_length);const base_dist=new Array(30);function StaticTreeDesc(static_tree,extra_bits,extra_base,elems,max_length){this.static_tree=static_tree,this.extra_bits=extra_bits,this.extra_base=extra_base,this.elems=elems,this.max_length=max_length,this.has_stree=static_tree&&static_tree.length}let static_l_desc,static_d_desc,static_bl_desc;function TreeDesc(dyn_tree,stat_desc){this.dyn_tree=dyn_tree,this.max_code=0,this.stat_desc=stat_desc}zero$1(base_dist);const d_code=dist=>dist<256?_dist_code[dist]:_dist_code[256+(dist>>>7)],put_short=(s,w)=>{s.pending_buf[s.pending++]=255&w,s.pending_buf[s.pending++]=w>>>8&255},send_bits=(s,value,length)=>{s.bi_valid>16-length?(s.bi_buf|=value<<s.bi_valid&65535,put_short(s,s.bi_buf),s.bi_buf=value>>16-s.bi_valid,s.bi_valid+=length-16):(s.bi_buf|=value<<s.bi_valid&65535,s.bi_valid+=length)},send_code=(s,c,tree)=>{send_bits(s,tree[2*c],tree[2*c+1])},bi_reverse=(code,len)=>{let res=0;do{res|=1&code,code>>>=1,res<<=1}while(--len>0);return res>>>1},gen_codes=(tree,max_code,bl_count)=>{const next_code=new Array(16);let bits,n,code=0;for(bits=1;bits<=15;bits++)next_code[bits]=code=code+bl_count[bits-1]<<1;for(n=0;n<=max_code;n++){let len=tree[2*n+1];0!==len&&(tree[2*n]=bi_reverse(next_code[len]++,len))}},init_block=s=>{let n;for(n=0;n<286;n++)s.dyn_ltree[2*n]=0;for(n=0;n<30;n++)s.dyn_dtree[2*n]=0;for(n=0;n<19;n++)s.bl_tree[2*n]=0;s.dyn_ltree[512]=1,s.opt_len=s.static_len=0,s.last_lit=s.matches=0},bi_windup=s=>{s.bi_valid>8?put_short(s,s.bi_buf):s.bi_valid>0&&(s.pending_buf[s.pending++]=s.bi_buf),s.bi_buf=0,s.bi_valid=0},smaller=(tree,n,m,depth)=>{const _n2=2*n,_m2=2*m;return tree[_n2]<tree[_m2]||tree[_n2]===tree[_m2]&&depth[n]<=depth[m]},pqdownheap=(s,tree,k)=>{const v=s.heap[k];let j=k<<1;for(;j<=s.heap_len&&(j<s.heap_len&&smaller(tree,s.heap[j+1],s.heap[j],s.depth)&&j++,!smaller(tree,v,s.heap[j],s.depth));)s.heap[k]=s.heap[j],k=j,j<<=1;s.heap[k]=v},compress_block=(s,ltree,dtree)=>{let dist,lc,code,extra,lx=0;if(0!==s.last_lit)do{dist=s.pending_buf[s.d_buf+2*lx]<<8|s.pending_buf[s.d_buf+2*lx+1],lc=s.pending_buf[s.l_buf+lx],lx++,0===dist?send_code(s,lc,ltree):(code=_length_code[lc],send_code(s,code+256+1,ltree),extra=extra_lbits[code],0!==extra&&(lc-=base_length[code],send_bits(s,lc,extra)),dist--,code=d_code(dist),send_code(s,code,dtree),extra=extra_dbits[code],0!==extra&&(dist-=base_dist[code],send_bits(s,dist,extra)))}while(lx<s.last_lit);send_code(s,256,ltree)},build_tree=(s,desc)=>{const tree=desc.dyn_tree,stree=desc.stat_desc.static_tree,has_stree=desc.stat_desc.has_stree,elems=desc.stat_desc.elems;let n,m,node,max_code=-1;for(s.heap_len=0,s.heap_max=573,n=0;n<elems;n++)0!==tree[2*n]?(s.heap[++s.heap_len]=max_code=n,s.depth[n]=0):tree[2*n+1]=0;for(;s.heap_len<2;)node=s.heap[++s.heap_len]=max_code<2?++max_code:0,tree[2*node]=1,s.depth[node]=0,s.opt_len--,has_stree&&(s.static_len-=stree[2*node+1]);for(desc.max_code=max_code,n=s.heap_len>>1;n>=1;n--)pqdownheap(s,tree,n);node=elems;do{n=s.heap[1],s.heap[1]=s.heap[s.heap_len--],pqdownheap(s,tree,1),m=s.heap[1],s.heap[--s.heap_max]=n,s.heap[--s.heap_max]=m,tree[2*node]=tree[2*n]+tree[2*m],s.depth[node]=(s.depth[n]>=s.depth[m]?s.depth[n]:s.depth[m])+1,tree[2*n+1]=tree[2*m+1]=node,s.heap[1]=node++,pqdownheap(s,tree,1)}while(s.heap_len>=2);s.heap[--s.heap_max]=s.heap[1],((s,desc)=>{const tree=desc.dyn_tree,max_code=desc.max_code,stree=desc.stat_desc.static_tree,has_stree=desc.stat_desc.has_stree,extra=desc.stat_desc.extra_bits,base=desc.stat_desc.extra_base,max_length=desc.stat_desc.max_length;let h,n,m,bits,xbits,f,overflow=0;for(bits=0;bits<=15;bits++)s.bl_count[bits]=0;for(tree[2*s.heap[s.heap_max]+1]=0,h=s.heap_max+1;h<573;h++)n=s.heap[h],bits=tree[2*tree[2*n+1]+1]+1,bits>max_length&&(bits=max_length,overflow++),tree[2*n+1]=bits,n>max_code||(s.bl_count[bits]++,xbits=0,n>=base&&(xbits=extra[n-base]),f=tree[2*n],s.opt_len+=f*(bits+xbits),has_stree&&(s.static_len+=f*(stree[2*n+1]+xbits)));if(0!==overflow){do{for(bits=max_length-1;0===s.bl_count[bits];)bits--;s.bl_count[bits]--,s.bl_count[bits+1]+=2,s.bl_count[max_length]--,overflow-=2}while(overflow>0);for(bits=max_length;0!==bits;bits--)for(n=s.bl_count[bits];0!==n;)m=s.heap[--h],m>max_code||(tree[2*m+1]!==bits&&(s.opt_len+=(bits-tree[2*m+1])*tree[2*m],tree[2*m+1]=bits),n--)}})(s,desc),gen_codes(tree,max_code,s.bl_count)},scan_tree=(s,tree,max_code)=>{let n,curlen,prevlen=-1,nextlen=tree[1],count=0,max_count=7,min_count=4;for(0===nextlen&&(max_count=138,min_count=3),tree[2*(max_code+1)+1]=65535,n=0;n<=max_code;n++)curlen=nextlen,nextlen=tree[2*(n+1)+1],++count<max_count&&curlen===nextlen||(count<min_count?s.bl_tree[2*curlen]+=count:0!==curlen?(curlen!==prevlen&&s.bl_tree[2*curlen]++,s.bl_tree[32]++):count<=10?s.bl_tree[34]++:s.bl_tree[36]++,count=0,prevlen=curlen,0===nextlen?(max_count=138,min_count=3):curlen===nextlen?(max_count=6,min_count=3):(max_count=7,min_count=4))},send_tree=(s,tree,max_code)=>{let n,curlen,prevlen=-1,nextlen=tree[1],count=0,max_count=7,min_count=4;for(0===nextlen&&(max_count=138,min_count=3),n=0;n<=max_code;n++)if(curlen=nextlen,nextlen=tree[2*(n+1)+1],!(++count<max_count&&curlen===nextlen)){if(count<min_count)do{send_code(s,curlen,s.bl_tree)}while(0!=--count);else 0!==curlen?(curlen!==prevlen&&(send_code(s,curlen,s.bl_tree),count--),send_code(s,16,s.bl_tree),send_bits(s,count-3,2)):count<=10?(send_code(s,17,s.bl_tree),send_bits(s,count-3,3)):(send_code(s,18,s.bl_tree),send_bits(s,count-11,7));count=0,prevlen=curlen,0===nextlen?(max_count=138,min_count=3):curlen===nextlen?(max_count=6,min_count=3):(max_count=7,min_count=4)}};let static_init_done=!1;const _tr_stored_block$1=(s,buf,stored_len,last)=>{send_bits(s,0+(last?1:0),3),((s,buf,len,header)=>{bi_windup(s),header&&(put_short(s,len),put_short(s,~len)),s.pending_buf.set(s.window.subarray(buf,buf+len),s.pending),s.pending+=len})(s,buf,stored_len,!0)};var _tr_flush_block_1=(s,buf,stored_len,last)=>{let opt_lenb,static_lenb,max_blindex=0;s.level>0?(2===s.strm.data_type&&(s.strm.data_type=(s=>{let n,black_mask=4093624447;for(n=0;n<=31;n++,black_mask>>>=1)if(1&black_mask&&0!==s.dyn_ltree[2*n])return 0;if(0!==s.dyn_ltree[18]||0!==s.dyn_ltree[20]||0!==s.dyn_ltree[26])return 1;for(n=32;n<256;n++)if(0!==s.dyn_ltree[2*n])return 1;return 0})(s)),build_tree(s,s.l_desc),build_tree(s,s.d_desc),max_blindex=(s=>{let max_blindex;for(scan_tree(s,s.dyn_ltree,s.l_desc.max_code),scan_tree(s,s.dyn_dtree,s.d_desc.max_code),build_tree(s,s.bl_desc),max_blindex=18;max_blindex>=3&&0===s.bl_tree[2*bl_order[max_blindex]+1];max_blindex--);return s.opt_len+=3*(max_blindex+1)+5+5+4,max_blindex})(s),opt_lenb=s.opt_len+3+7>>>3,static_lenb=s.static_len+3+7>>>3,static_lenb<=opt_lenb&&(opt_lenb=static_lenb)):opt_lenb=static_lenb=stored_len+5,stored_len+4<=opt_lenb&&-1!==buf?_tr_stored_block$1(s,buf,stored_len,last):4===s.strategy||static_lenb===opt_lenb?(send_bits(s,2+(last?1:0),3),compress_block(s,static_ltree,static_dtree)):(send_bits(s,4+(last?1:0),3),((s,lcodes,dcodes,blcodes)=>{let rank;for(send_bits(s,lcodes-257,5),send_bits(s,dcodes-1,5),send_bits(s,blcodes-4,4),rank=0;rank<blcodes;rank++)send_bits(s,s.bl_tree[2*bl_order[rank]+1],3);send_tree(s,s.dyn_ltree,lcodes-1),send_tree(s,s.dyn_dtree,dcodes-1)})(s,s.l_desc.max_code+1,s.d_desc.max_code+1,max_blindex+1),compress_block(s,s.dyn_ltree,s.dyn_dtree)),init_block(s),last&&bi_windup(s)},trees={_tr_init:s=>{static_init_done||((()=>{let n,bits,length,code,dist;const bl_count=new Array(16);for(length=0,code=0;code<28;code++)for(base_length[code]=length,n=0;n<1<<extra_lbits[code];n++)_length_code[length++]=code;for(_length_code[length-1]=code,dist=0,code=0;code<16;code++)for(base_dist[code]=dist,n=0;n<1<<extra_dbits[code];n++)_dist_code[dist++]=code;for(dist>>=7;code<30;code++)for(base_dist[code]=dist<<7,n=0;n<1<<extra_dbits[code]-7;n++)_dist_code[256+dist++]=code;for(bits=0;bits<=15;bits++)bl_count[bits]=0;for(n=0;n<=143;)static_ltree[2*n+1]=8,n++,bl_count[8]++;for(;n<=255;)static_ltree[2*n+1]=9,n++,bl_count[9]++;for(;n<=279;)static_ltree[2*n+1]=7,n++,bl_count[7]++;for(;n<=287;)static_ltree[2*n+1]=8,n++,bl_count[8]++;for(gen_codes(static_ltree,287,bl_count),n=0;n<30;n++)static_dtree[2*n+1]=5,static_dtree[2*n]=bi_reverse(n,5);static_l_desc=new StaticTreeDesc(static_ltree,extra_lbits,257,286,15),static_d_desc=new StaticTreeDesc(static_dtree,extra_dbits,0,30,15),static_bl_desc=new StaticTreeDesc(new Array(0),extra_blbits,0,19,7)})(),static_init_done=!0),s.l_desc=new TreeDesc(s.dyn_ltree,static_l_desc),s.d_desc=new TreeDesc(s.dyn_dtree,static_d_desc),s.bl_desc=new TreeDesc(s.bl_tree,static_bl_desc),s.bi_buf=0,s.bi_valid=0,init_block(s)},_tr_stored_block:_tr_stored_block$1,_tr_flush_block:_tr_flush_block_1,_tr_tally:(s,dist,lc)=>(s.pending_buf[s.d_buf+2*s.last_lit]=dist>>>8&255,s.pending_buf[s.d_buf+2*s.last_lit+1]=255&dist,s.pending_buf[s.l_buf+s.last_lit]=255&lc,s.last_lit++,0===dist?s.dyn_ltree[2*lc]++:(s.matches++,dist--,s.dyn_ltree[2*(_length_code[lc]+256+1)]++,s.dyn_dtree[2*d_code(dist)]++),s.last_lit===s.lit_bufsize-1),_tr_align:s=>{send_bits(s,2,3),send_code(s,256,static_ltree),(s=>{16===s.bi_valid?(put_short(s,s.bi_buf),s.bi_buf=0,s.bi_valid=0):s.bi_valid>=8&&(s.pending_buf[s.pending++]=255&s.bi_buf,s.bi_buf>>=8,s.bi_valid-=8)})(s)}};var adler32_1=(adler,buf,len,pos)=>{let s1=65535&adler|0,s2=adler>>>16&65535|0,n=0;for(;0!==len;){n=len>2e3?2e3:len,len-=n;do{s1=s1+buf[pos++]|0,s2=s2+s1|0}while(--n);s1%=65521,s2%=65521}return s1|s2<<16|0};const crcTable=new Uint32Array((()=>{let c,table=[];for(var n=0;n<256;n++){c=n;for(var k=0;k<8;k++)c=1&c?3988292384^c>>>1:c>>>1;table[n]=c}return table})());var crc32_1=(crc,buf,len,pos)=>{const t=crcTable,end=pos+len;crc^=-1;for(let i=pos;i<end;i++)crc=crc>>>8^t[255&(crc^buf[i])];return-1^crc},messages={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},constants$2={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8};const{_tr_init:_tr_init,_tr_stored_block:_tr_stored_block,_tr_flush_block:_tr_flush_block,_tr_tally:_tr_tally,_tr_align:_tr_align}=trees,{Z_NO_FLUSH:Z_NO_FLUSH$2,Z_PARTIAL_FLUSH:Z_PARTIAL_FLUSH,Z_FULL_FLUSH:Z_FULL_FLUSH$1,Z_FINISH:Z_FINISH$3,Z_BLOCK:Z_BLOCK$1,Z_OK:Z_OK$3,Z_STREAM_END:Z_STREAM_END$3,Z_STREAM_ERROR:Z_STREAM_ERROR$2,Z_DATA_ERROR:Z_DATA_ERROR$2,Z_BUF_ERROR:Z_BUF_ERROR$1,Z_DEFAULT_COMPRESSION:Z_DEFAULT_COMPRESSION$1,Z_FILTERED:Z_FILTERED,Z_HUFFMAN_ONLY:Z_HUFFMAN_ONLY,Z_RLE:Z_RLE,Z_FIXED:Z_FIXED,Z_DEFAULT_STRATEGY:Z_DEFAULT_STRATEGY$1,Z_UNKNOWN:Z_UNKNOWN,Z_DEFLATED:Z_DEFLATED$2}=constants$2,err=(strm,errorCode)=>(strm.msg=messages[errorCode],errorCode),rank=f=>(f<<1)-(f>4?9:0),zero=buf=>{let len=buf.length;for(;--len>=0;)buf[len]=0};let HASH=(s,prev,data)=>(prev<<s.hash_shift^data)&s.hash_mask;const flush_pending=strm=>{const s=strm.state;let len=s.pending;len>strm.avail_out&&(len=strm.avail_out),0!==len&&(strm.output.set(s.pending_buf.subarray(s.pending_out,s.pending_out+len),strm.next_out),strm.next_out+=len,s.pending_out+=len,strm.total_out+=len,strm.avail_out-=len,s.pending-=len,0===s.pending&&(s.pending_out=0))},flush_block_only=(s,last)=>{_tr_flush_block(s,s.block_start>=0?s.block_start:-1,s.strstart-s.block_start,last),s.block_start=s.strstart,flush_pending(s.strm)},put_byte=(s,b)=>{s.pending_buf[s.pending++]=b},putShortMSB=(s,b)=>{s.pending_buf[s.pending++]=b>>>8&255,s.pending_buf[s.pending++]=255&b},read_buf=(strm,buf,start,size)=>{let len=strm.avail_in;return len>size&&(len=size),0===len?0:(strm.avail_in-=len,buf.set(strm.input.subarray(strm.next_in,strm.next_in+len),start),1===strm.state.wrap?strm.adler=adler32_1(strm.adler,buf,len,start):2===strm.state.wrap&&(strm.adler=crc32_1(strm.adler,buf,len,start)),strm.next_in+=len,strm.total_in+=len,len)},longest_match=(s,cur_match)=>{let match,len,chain_length=s.max_chain_length,scan=s.strstart,best_len=s.prev_length,nice_match=s.nice_match;const limit=s.strstart>s.w_size-262?s.strstart-(s.w_size-262):0,_win=s.window,wmask=s.w_mask,prev=s.prev,strend=s.strstart+258;let scan_end1=_win[scan+best_len-1],scan_end=_win[scan+best_len];s.prev_length>=s.good_match&&(chain_length>>=2),nice_match>s.lookahead&&(nice_match=s.lookahead);do{if(match=cur_match,_win[match+best_len]===scan_end&&_win[match+best_len-1]===scan_end1&&_win[match]===_win[scan]&&_win[++match]===_win[scan+1]){scan+=2,match++;do{}while(_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&scan<strend);if(len=258-(strend-scan),scan=strend-258,len>best_len){if(s.match_start=cur_match,best_len=len,len>=nice_match)break;scan_end1=_win[scan+best_len-1],scan_end=_win[scan+best_len]}}}while((cur_match=prev[cur_match&wmask])>limit&&0!=--chain_length);return best_len<=s.lookahead?best_len:s.lookahead},fill_window=s=>{const _w_size=s.w_size;let p,n,m,more,str;do{if(more=s.window_size-s.lookahead-s.strstart,s.strstart>=_w_size+(_w_size-262)){s.window.set(s.window.subarray(_w_size,_w_size+_w_size),0),s.match_start-=_w_size,s.strstart-=_w_size,s.block_start-=_w_size,n=s.hash_size,p=n;do{m=s.head[--p],s.head[p]=m>=_w_size?m-_w_size:0}while(--n);n=_w_size,p=n;do{m=s.prev[--p],s.prev[p]=m>=_w_size?m-_w_size:0}while(--n);more+=_w_size}if(0===s.strm.avail_in)break;if(n=read_buf(s.strm,s.window,s.strstart+s.lookahead,more),s.lookahead+=n,s.lookahead+s.insert>=3)for(str=s.strstart-s.insert,s.ins_h=s.window[str],s.ins_h=HASH(s,s.ins_h,s.window[str+1]);s.insert&&(s.ins_h=HASH(s,s.ins_h,s.window[str+3-1]),s.prev[str&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=str,str++,s.insert--,!(s.lookahead+s.insert<3)););}while(s.lookahead<262&&0!==s.strm.avail_in)},deflate_fast=(s,flush)=>{let hash_head,bflush;for(;;){if(s.lookahead<262){if(fill_window(s),s.lookahead<262&&flush===Z_NO_FLUSH$2)return 1;if(0===s.lookahead)break}if(hash_head=0,s.lookahead>=3&&(s.ins_h=HASH(s,s.ins_h,s.window[s.strstart+3-1]),hash_head=s.prev[s.strstart&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=s.strstart),0!==hash_head&&s.strstart-hash_head<=s.w_size-262&&(s.match_length=longest_match(s,hash_head)),s.match_length>=3)if(bflush=_tr_tally(s,s.strstart-s.match_start,s.match_length-3),s.lookahead-=s.match_length,s.match_length<=s.max_lazy_match&&s.lookahead>=3){s.match_length--;do{s.strstart++,s.ins_h=HASH(s,s.ins_h,s.window[s.strstart+3-1]),hash_head=s.prev[s.strstart&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=s.strstart}while(0!=--s.match_length);s.strstart++}else s.strstart+=s.match_length,s.match_length=0,s.ins_h=s.window[s.strstart],s.ins_h=HASH(s,s.ins_h,s.window[s.strstart+1]);else bflush=_tr_tally(s,0,s.window[s.strstart]),s.lookahead--,s.strstart++;if(bflush&&(flush_block_only(s,!1),0===s.strm.avail_out))return 1}return s.insert=s.strstart<2?s.strstart:2,flush===Z_FINISH$3?(flush_block_only(s,!0),0===s.strm.avail_out?3:4):s.last_lit&&(flush_block_only(s,!1),0===s.strm.avail_out)?1:2},deflate_slow=(s,flush)=>{let hash_head,bflush,max_insert;for(;;){if(s.lookahead<262){if(fill_window(s),s.lookahead<262&&flush===Z_NO_FLUSH$2)return 1;if(0===s.lookahead)break}if(hash_head=0,s.lookahead>=3&&(s.ins_h=HASH(s,s.ins_h,s.window[s.strstart+3-1]),hash_head=s.prev[s.strstart&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=s.strstart),s.prev_length=s.match_length,s.prev_match=s.match_start,s.match_length=2,0!==hash_head&&s.prev_length<s.max_lazy_match&&s.strstart-hash_head<=s.w_size-262&&(s.match_length=longest_match(s,hash_head),s.match_length<=5&&(s.strategy===Z_FILTERED||3===s.match_length&&s.strstart-s.match_start>4096)&&(s.match_length=2)),s.prev_length>=3&&s.match_length<=s.prev_length){max_insert=s.strstart+s.lookahead-3,bflush=_tr_tally(s,s.strstart-1-s.prev_match,s.prev_length-3),s.lookahead-=s.prev_length-1,s.prev_length-=2;do{++s.strstart<=max_insert&&(s.ins_h=HASH(s,s.ins_h,s.window[s.strstart+3-1]),hash_head=s.prev[s.strstart&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=s.strstart)}while(0!=--s.prev_length);if(s.match_available=0,s.match_length=2,s.strstart++,bflush&&(flush_block_only(s,!1),0===s.strm.avail_out))return 1}else if(s.match_available){if(bflush=_tr_tally(s,0,s.window[s.strstart-1]),bflush&&flush_block_only(s,!1),s.strstart++,s.lookahead--,0===s.strm.avail_out)return 1}else s.match_available=1,s.strstart++,s.lookahead--}return s.match_available&&(bflush=_tr_tally(s,0,s.window[s.strstart-1]),s.match_available=0),s.insert=s.strstart<2?s.strstart:2,flush===Z_FINISH$3?(flush_block_only(s,!0),0===s.strm.avail_out?3:4):s.last_lit&&(flush_block_only(s,!1),0===s.strm.avail_out)?1:2};function Config(good_length,max_lazy,nice_length,max_chain,func){this.good_length=good_length,this.max_lazy=max_lazy,this.nice_length=nice_length,this.max_chain=max_chain,this.func=func}const configuration_table=[new Config(0,0,0,0,((s,flush)=>{let max_block_size=65535;for(max_block_size>s.pending_buf_size-5&&(max_block_size=s.pending_buf_size-5);;){if(s.lookahead<=1){if(fill_window(s),0===s.lookahead&&flush===Z_NO_FLUSH$2)return 1;if(0===s.lookahead)break}s.strstart+=s.lookahead,s.lookahead=0;const max_start=s.block_start+max_block_size;if((0===s.strstart||s.strstart>=max_start)&&(s.lookahead=s.strstart-max_start,s.strstart=max_start,flush_block_only(s,!1),0===s.strm.avail_out))return 1;if(s.strstart-s.block_start>=s.w_size-262&&(flush_block_only(s,!1),0===s.strm.avail_out))return 1}return s.insert=0,flush===Z_FINISH$3?(flush_block_only(s,!0),0===s.strm.avail_out?3:4):(s.strstart>s.block_start&&(flush_block_only(s,!1),s.strm.avail_out),1)})),new Config(4,4,8,4,deflate_fast),new Config(4,5,16,8,deflate_fast),new Config(4,6,32,32,deflate_fast),new Config(4,4,16,16,deflate_slow),new Config(8,16,32,32,deflate_slow),new Config(8,16,128,128,deflate_slow),new Config(8,32,128,256,deflate_slow),new Config(32,128,258,1024,deflate_slow),new Config(32,258,258,4096,deflate_slow)];function DeflateState(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=Z_DEFLATED$2,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(1146),this.dyn_dtree=new Uint16Array(122),this.bl_tree=new Uint16Array(78),zero(this.dyn_ltree),zero(this.dyn_dtree),zero(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(16),this.heap=new Uint16Array(573),zero(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(573),zero(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}const deflateResetKeep=strm=>{if(!strm||!strm.state)return err(strm,Z_STREAM_ERROR$2);strm.total_in=strm.total_out=0,strm.data_type=Z_UNKNOWN;const s=strm.state;return s.pending=0,s.pending_out=0,s.wrap<0&&(s.wrap=-s.wrap),s.status=s.wrap?42:113,strm.adler=2===s.wrap?0:1,s.last_flush=Z_NO_FLUSH$2,_tr_init(s),Z_OK$3},deflateReset=strm=>{const ret=deflateResetKeep(strm);var s;return ret===Z_OK$3&&((s=strm.state).window_size=2*s.w_size,zero(s.head),s.max_lazy_match=configuration_table[s.level].max_lazy,s.good_match=configuration_table[s.level].good_length,s.nice_match=configuration_table[s.level].nice_length,s.max_chain_length=configuration_table[s.level].max_chain,s.strstart=0,s.block_start=0,s.lookahead=0,s.insert=0,s.match_length=s.prev_length=2,s.match_available=0,s.ins_h=0),ret},deflateInit2=(strm,level,method,windowBits,memLevel,strategy)=>{if(!strm)return Z_STREAM_ERROR$2;let wrap=1;if(level===Z_DEFAULT_COMPRESSION$1&&(level=6),windowBits<0?(wrap=0,windowBits=-windowBits):windowBits>15&&(wrap=2,windowBits-=16),memLevel<1||memLevel>9||method!==Z_DEFLATED$2||windowBits<8||windowBits>15||level<0||level>9||strategy<0||strategy>Z_FIXED)return err(strm,Z_STREAM_ERROR$2);8===windowBits&&(windowBits=9);const s=new DeflateState;return strm.state=s,s.strm=strm,s.wrap=wrap,s.gzhead=null,s.w_bits=windowBits,s.w_size=1<<s.w_bits,s.w_mask=s.w_size-1,s.hash_bits=memLevel+7,s.hash_size=1<<s.hash_bits,s.hash_mask=s.hash_size-1,s.hash_shift=~~((s.hash_bits+3-1)/3),s.window=new Uint8Array(2*s.w_size),s.head=new Uint16Array(s.hash_size),s.prev=new Uint16Array(s.w_size),s.lit_bufsize=1<<memLevel+6,s.pending_buf_size=4*s.lit_bufsize,s.pending_buf=new Uint8Array(s.pending_buf_size),s.d_buf=1*s.lit_bufsize,s.l_buf=3*s.lit_bufsize,s.level=level,s.strategy=strategy,s.method=method,deflateReset(strm)};var deflate_1$2={deflateInit:(strm,level)=>deflateInit2(strm,level,Z_DEFLATED$2,15,8,Z_DEFAULT_STRATEGY$1),deflateInit2:deflateInit2,deflateReset:deflateReset,deflateResetKeep:deflateResetKeep,deflateSetHeader:(strm,head)=>strm&&strm.state?2!==strm.state.wrap?Z_STREAM_ERROR$2:(strm.state.gzhead=head,Z_OK$3):Z_STREAM_ERROR$2,deflate:(strm,flush)=>{let beg,val;if(!strm||!strm.state||flush>Z_BLOCK$1||flush<0)return strm?err(strm,Z_STREAM_ERROR$2):Z_STREAM_ERROR$2;const s=strm.state;if(!strm.output||!strm.input&&0!==strm.avail_in||666===s.status&&flush!==Z_FINISH$3)return err(strm,0===strm.avail_out?Z_BUF_ERROR$1:Z_STREAM_ERROR$2);s.strm=strm;const old_flush=s.last_flush;if(s.last_flush=flush,42===s.status)if(2===s.wrap)strm.adler=0,put_byte(s,31),put_byte(s,139),put_byte(s,8),s.gzhead?(put_byte(s,(s.gzhead.text?1:0)+(s.gzhead.hcrc?2:0)+(s.gzhead.extra?4:0)+(s.gzhead.name?8:0)+(s.gzhead.comment?16:0)),put_byte(s,255&s.gzhead.time),put_byte(s,s.gzhead.time>>8&255),put_byte(s,s.gzhead.time>>16&255),put_byte(s,s.gzhead.time>>24&255),put_byte(s,9===s.level?2:s.strategy>=Z_HUFFMAN_ONLY||s.level<2?4:0),put_byte(s,255&s.gzhead.os),s.gzhead.extra&&s.gzhead.extra.length&&(put_byte(s,255&s.gzhead.extra.length),put_byte(s,s.gzhead.extra.length>>8&255)),s.gzhead.hcrc&&(strm.adler=crc32_1(strm.adler,s.pending_buf,s.pending,0)),s.gzindex=0,s.status=69):(put_byte(s,0),put_byte(s,0),put_byte(s,0),put_byte(s,0),put_byte(s,0),put_byte(s,9===s.level?2:s.strategy>=Z_HUFFMAN_ONLY||s.level<2?4:0),put_byte(s,3),s.status=113);else{let header=Z_DEFLATED$2+(s.w_bits-8<<4)<<8,level_flags=-1;level_flags=s.strategy>=Z_HUFFMAN_ONLY||s.level<2?0:s.level<6?1:6===s.level?2:3,header|=level_flags<<6,0!==s.strstart&&(header|=32),header+=31-header%31,s.status=113,putShortMSB(s,header),0!==s.strstart&&(putShortMSB(s,strm.adler>>>16),putShortMSB(s,65535&strm.adler)),strm.adler=1}if(69===s.status)if(s.gzhead.extra){for(beg=s.pending;s.gzindex<(65535&s.gzhead.extra.length)&&(s.pending!==s.pending_buf_size||(s.gzhead.hcrc&&s.pending>beg&&(strm.adler=crc32_1(strm.adler,s.pending_buf,s.pending-beg,beg)),flush_pending(strm),beg=s.pending,s.pending!==s.pending_buf_size));)put_byte(s,255&s.gzhead.extra[s.gzindex]),s.gzindex++;s.gzhead.hcrc&&s.pending>beg&&(strm.adler=crc32_1(strm.adler,s.pending_buf,s.pending-beg,beg)),s.gzindex===s.gzhead.extra.length&&(s.gzindex=0,s.status=73)}else s.status=73;if(73===s.status)if(s.gzhead.name){beg=s.pending;do{if(s.pending===s.pending_buf_size&&(s.gzhead.hcrc&&s.pending>beg&&(strm.adler=crc32_1(strm.adler,s.pending_buf,s.pending-beg,beg)),flush_pending(strm),beg=s.pending,s.pending===s.pending_buf_size)){val=1;break}val=s.gzindex<s.gzhead.name.length?255&s.gzhead.name.charCodeAt(s.gzindex++):0,put_byte(s,val)}while(0!==val);s.gzhead.hcrc&&s.pending>beg&&(strm.adler=crc32_1(strm.adler,s.pending_buf,s.pending-beg,beg)),0===val&&(s.gzindex=0,s.status=91)}else s.status=91;if(91===s.status)if(s.gzhead.comment){beg=s.pending;do{if(s.pending===s.pending_buf_size&&(s.gzhead.hcrc&&s.pending>beg&&(strm.adler=crc32_1(strm.adler,s.pending_buf,s.pending-beg,beg)),flush_pending(strm),beg=s.pending,s.pending===s.pending_buf_size)){val=1;break}val=s.gzindex<s.gzhead.comment.length?255&s.gzhead.comment.charCodeAt(s.gzindex++):0,put_byte(s,val)}while(0!==val);s.gzhead.hcrc&&s.pending>beg&&(strm.adler=crc32_1(strm.adler,s.pending_buf,s.pending-beg,beg)),0===val&&(s.status=103)}else s.status=103;if(103===s.status&&(s.gzhead.hcrc?(s.pending+2>s.pending_buf_size&&flush_pending(strm),s.pending+2<=s.pending_buf_size&&(put_byte(s,255&strm.adler),put_byte(s,strm.adler>>8&255),strm.adler=0,s.status=113)):s.status=113),0!==s.pending){if(flush_pending(strm),0===strm.avail_out)return s.last_flush=-1,Z_OK$3}else if(0===strm.avail_in&&rank(flush)<=rank(old_flush)&&flush!==Z_FINISH$3)return err(strm,Z_BUF_ERROR$1);if(666===s.status&&0!==strm.avail_in)return err(strm,Z_BUF_ERROR$1);if(0!==strm.avail_in||0!==s.lookahead||flush!==Z_NO_FLUSH$2&&666!==s.status){let bstate=s.strategy===Z_HUFFMAN_ONLY?((s,flush)=>{let bflush;for(;;){if(0===s.lookahead&&(fill_window(s),0===s.lookahead)){if(flush===Z_NO_FLUSH$2)return 1;break}if(s.match_length=0,bflush=_tr_tally(s,0,s.window[s.strstart]),s.lookahead--,s.strstart++,bflush&&(flush_block_only(s,!1),0===s.strm.avail_out))return 1}return s.insert=0,flush===Z_FINISH$3?(flush_block_only(s,!0),0===s.strm.avail_out?3:4):s.last_lit&&(flush_block_only(s,!1),0===s.strm.avail_out)?1:2})(s,flush):s.strategy===Z_RLE?((s,flush)=>{let bflush,prev,scan,strend;const _win=s.window;for(;;){if(s.lookahead<=258){if(fill_window(s),s.lookahead<=258&&flush===Z_NO_FLUSH$2)return 1;if(0===s.lookahead)break}if(s.match_length=0,s.lookahead>=3&&s.strstart>0&&(scan=s.strstart-1,prev=_win[scan],prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan])){strend=s.strstart+258;do{}while(prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&scan<strend);s.match_length=258-(strend-scan),s.match_length>s.lookahead&&(s.match_length=s.lookahead)}if(s.match_length>=3?(bflush=_tr_tally(s,1,s.match_length-3),s.lookahead-=s.match_length,s.strstart+=s.match_length,s.match_length=0):(bflush=_tr_tally(s,0,s.window[s.strstart]),s.lookahead--,s.strstart++),bflush&&(flush_block_only(s,!1),0===s.strm.avail_out))return 1}return s.insert=0,flush===Z_FINISH$3?(flush_block_only(s,!0),0===s.strm.avail_out?3:4):s.last_lit&&(flush_block_only(s,!1),0===s.strm.avail_out)?1:2})(s,flush):configuration_table[s.level].func(s,flush);if(3!==bstate&&4!==bstate||(s.status=666),1===bstate||3===bstate)return 0===strm.avail_out&&(s.last_flush=-1),Z_OK$3;if(2===bstate&&(flush===Z_PARTIAL_FLUSH?_tr_align(s):flush!==Z_BLOCK$1&&(_tr_stored_block(s,0,0,!1),flush===Z_FULL_FLUSH$1&&(zero(s.head),0===s.lookahead&&(s.strstart=0,s.block_start=0,s.insert=0))),flush_pending(strm),0===strm.avail_out))return s.last_flush=-1,Z_OK$3}return flush!==Z_FINISH$3?Z_OK$3:s.wrap<=0?Z_STREAM_END$3:(2===s.wrap?(put_byte(s,255&strm.adler),put_byte(s,strm.adler>>8&255),put_byte(s,strm.adler>>16&255),put_byte(s,strm.adler>>24&255),put_byte(s,255&strm.total_in),put_byte(s,strm.total_in>>8&255),put_byte(s,strm.total_in>>16&255),put_byte(s,strm.total_in>>24&255)):(putShortMSB(s,strm.adler>>>16),putShortMSB(s,65535&strm.adler)),flush_pending(strm),s.wrap>0&&(s.wrap=-s.wrap),0!==s.pending?Z_OK$3:Z_STREAM_END$3)},deflateEnd:strm=>{if(!strm||!strm.state)return Z_STREAM_ERROR$2;const status=strm.state.status;return 42!==status&&69!==status&&73!==status&&91!==status&&103!==status&&113!==status&&666!==status?err(strm,Z_STREAM_ERROR$2):(strm.state=null,113===status?err(strm,Z_DATA_ERROR$2):Z_OK$3)},deflateSetDictionary:(strm,dictionary)=>{let dictLength=dictionary.length;if(!strm||!strm.state)return Z_STREAM_ERROR$2;const s=strm.state,wrap=s.wrap;if(2===wrap||1===wrap&&42!==s.status||s.lookahead)return Z_STREAM_ERROR$2;if(1===wrap&&(strm.adler=adler32_1(strm.adler,dictionary,dictLength,0)),s.wrap=0,dictLength>=s.w_size){0===wrap&&(zero(s.head),s.strstart=0,s.block_start=0,s.insert=0);let tmpDict=new Uint8Array(s.w_size);tmpDict.set(dictionary.subarray(dictLength-s.w_size,dictLength),0),dictionary=tmpDict,dictLength=s.w_size}const avail=strm.avail_in,next=strm.next_in,input=strm.input;for(strm.avail_in=dictLength,strm.next_in=0,strm.input=dictionary,fill_window(s);s.lookahead>=3;){let str=s.strstart,n=s.lookahead-2;do{s.ins_h=HASH(s,s.ins_h,s.window[str+3-1]),s.prev[str&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=str,str++}while(--n);s.strstart=str,s.lookahead=2,fill_window(s)}return s.strstart+=s.lookahead,s.block_start=s.strstart,s.insert=s.lookahead,s.lookahead=0,s.match_length=s.prev_length=2,s.match_available=0,strm.next_in=next,strm.input=input,strm.avail_in=avail,s.wrap=wrap,Z_OK$3},deflateInfo:"pako deflate (from Nodeca project)"};const _has=(obj,key)=>Object.prototype.hasOwnProperty.call(obj,key);var common_assign=function(obj){const sources=Array.prototype.slice.call(arguments,1);for(;sources.length;){const source=sources.shift();if(source){if("object"!=typeof source)throw new TypeError(source+"must be non-object");for(const p in source)_has(source,p)&&(obj[p]=source[p])}}return obj},common_flattenChunks=chunks=>{let len=0;for(let i=0,l=chunks.length;i<l;i++)len+=chunks[i].length;const result=new Uint8Array(len);for(let i=0,pos=0,l=chunks.length;i<l;i++){let chunk=chunks[i];result.set(chunk,pos),pos+=chunk.length}return result};let STR_APPLY_UIA_OK=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(__){STR_APPLY_UIA_OK=!1}const _utf8len=new Uint8Array(256);for(let q=0;q<256;q++)_utf8len[q]=q>=252?6:q>=248?5:q>=240?4:q>=224?3:q>=192?2:1;_utf8len[254]=_utf8len[254]=1;var strings_string2buf=str=>{if("function"==typeof TextEncoder&&TextEncoder.prototype.encode)return(new TextEncoder).encode(str);let buf,c,c2,m_pos,i,str_len=str.length,buf_len=0;for(m_pos=0;m_pos<str_len;m_pos++)c=str.charCodeAt(m_pos),55296==(64512&c)&&m_pos+1<str_len&&(c2=str.charCodeAt(m_pos+1),56320==(64512&c2)&&(c=65536+(c-55296<<10)+(c2-56320),m_pos++)),buf_len+=c<128?1:c<2048?2:c<65536?3:4;for(buf=new Uint8Array(buf_len),i=0,m_pos=0;i<buf_len;m_pos++)c=str.charCodeAt(m_pos),55296==(64512&c)&&m_pos+1<str_len&&(c2=str.charCodeAt(m_pos+1),56320==(64512&c2)&&(c=65536+(c-55296<<10)+(c2-56320),m_pos++)),c<128?buf[i++]=c:c<2048?(buf[i++]=192|c>>>6,buf[i++]=128|63&c):c<65536?(buf[i++]=224|c>>>12,buf[i++]=128|c>>>6&63,buf[i++]=128|63&c):(buf[i++]=240|c>>>18,buf[i++]=128|c>>>12&63,buf[i++]=128|c>>>6&63,buf[i++]=128|63&c);return buf},strings_buf2string=(buf,max)=>{const len=max||buf.length;if("function"==typeof TextDecoder&&TextDecoder.prototype.decode)return(new TextDecoder).decode(buf.subarray(0,max));let i,out;const utf16buf=new Array(2*len);for(out=0,i=0;i<len;){let c=buf[i++];if(c<128){utf16buf[out++]=c;continue}let c_len=_utf8len[c];if(c_len>4)utf16buf[out++]=65533,i+=c_len-1;else{for(c&=2===c_len?31:3===c_len?15:7;c_len>1&&i<len;)c=c<<6|63&buf[i++],c_len--;c_len>1?utf16buf[out++]=65533:c<65536?utf16buf[out++]=c:(c-=65536,utf16buf[out++]=55296|c>>10&1023,utf16buf[out++]=56320|1023&c)}}return((buf,len)=>{if(len<65534&&buf.subarray&&STR_APPLY_UIA_OK)return String.fromCharCode.apply(null,buf.length===len?buf:buf.subarray(0,len));let result="";for(let i=0;i<len;i++)result+=String.fromCharCode(buf[i]);return result})(utf16buf,out)},strings_utf8border=(buf,max)=>{(max=max||buf.length)>buf.length&&(max=buf.length);let pos=max-1;for(;pos>=0&&128==(192&buf[pos]);)pos--;return pos<0||0===pos?max:pos+_utf8len[buf[pos]]>max?pos:max};var zstream=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0};const toString$1=Object.prototype.toString,{Z_NO_FLUSH:Z_NO_FLUSH$1,Z_SYNC_FLUSH:Z_SYNC_FLUSH,Z_FULL_FLUSH:Z_FULL_FLUSH,Z_FINISH:Z_FINISH$2,Z_OK:Z_OK$2,Z_STREAM_END:Z_STREAM_END$2,Z_DEFAULT_COMPRESSION:Z_DEFAULT_COMPRESSION,Z_DEFAULT_STRATEGY:Z_DEFAULT_STRATEGY,Z_DEFLATED:Z_DEFLATED$1}=constants$2;function Deflate$1(options){this.options=common_assign({level:Z_DEFAULT_COMPRESSION,method:Z_DEFLATED$1,chunkSize:16384,windowBits:15,memLevel:8,strategy:Z_DEFAULT_STRATEGY},options||{});let opt=this.options;opt.raw&&opt.windowBits>0?opt.windowBits=-opt.windowBits:opt.gzip&&opt.windowBits>0&&opt.windowBits<16&&(opt.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new zstream,this.strm.avail_out=0;let status=deflate_1$2.deflateInit2(this.strm,opt.level,opt.method,opt.windowBits,opt.memLevel,opt.strategy);if(status!==Z_OK$2)throw new Error(messages[status]);if(opt.header&&deflate_1$2.deflateSetHeader(this.strm,opt.header),opt.dictionary){let dict;if(dict="string"==typeof opt.dictionary?strings_string2buf(opt.dictionary):"[object ArrayBuffer]"===toString$1.call(opt.dictionary)?new Uint8Array(opt.dictionary):opt.dictionary,status=deflate_1$2.deflateSetDictionary(this.strm,dict),status!==Z_OK$2)throw new Error(messages[status]);this._dict_set=!0}}function deflate$1(input,options){const deflator=new Deflate$1(options);if(deflator.push(input,!0),deflator.err)throw deflator.msg||messages[deflator.err];return deflator.result}Deflate$1.prototype.push=function(data,flush_mode){const strm=this.strm,chunkSize=this.options.chunkSize;let status,_flush_mode;if(this.ended)return!1;for(_flush_mode=flush_mode===~~flush_mode?flush_mode:!0===flush_mode?Z_FINISH$2:Z_NO_FLUSH$1,"string"==typeof data?strm.input=strings_string2buf(data):"[object ArrayBuffer]"===toString$1.call(data)?strm.input=new Uint8Array(data):strm.input=data,strm.next_in=0,strm.avail_in=strm.input.length;;)if(0===strm.avail_out&&(strm.output=new Uint8Array(chunkSize),strm.next_out=0,strm.avail_out=chunkSize),(_flush_mode===Z_SYNC_FLUSH||_flush_mode===Z_FULL_FLUSH)&&strm.avail_out<=6)this.onData(strm.output.subarray(0,strm.next_out)),strm.avail_out=0;else{if(status=deflate_1$2.deflate(strm,_flush_mode),status===Z_STREAM_END$2)return strm.next_out>0&&this.onData(strm.output.subarray(0,strm.next_out)),status=deflate_1$2.deflateEnd(this.strm),this.onEnd(status),this.ended=!0,status===Z_OK$2;if(0!==strm.avail_out){if(_flush_mode>0&&strm.next_out>0)this.onData(strm.output.subarray(0,strm.next_out)),strm.avail_out=0;else if(0===strm.avail_in)break}else this.onData(strm.output)}return!0},Deflate$1.prototype.onData=function(chunk){this.chunks.push(chunk)},Deflate$1.prototype.onEnd=function(status){status===Z_OK$2&&(this.result=common_flattenChunks(this.chunks)),this.chunks=[],this.err=status,this.msg=this.strm.msg};var deflate_1$1={Deflate:Deflate$1,deflate:deflate$1,deflateRaw:function(input,options){return(options=options||{}).raw=!0,deflate$1(input,options)},gzip:function(input,options){return(options=options||{}).gzip=!0,deflate$1(input,options)},constants:constants$2};var inffast=function(strm,start){let _in,last,_out,beg,end,dmax,wsize,whave,wnext,s_window,hold,bits,lcode,dcode,lmask,dmask,here,op,len,dist,from,from_source,input,output;const state=strm.state;_in=strm.next_in,input=strm.input,last=_in+(strm.avail_in-5),_out=strm.next_out,output=strm.output,beg=_out-(start-strm.avail_out),end=_out+(strm.avail_out-257),dmax=state.dmax,wsize=state.wsize,whave=state.whave,wnext=state.wnext,s_window=state.window,hold=state.hold,bits=state.bits,lcode=state.lencode,dcode=state.distcode,lmask=(1<<state.lenbits)-1,dmask=(1<<state.distbits)-1;top:do{bits<15&&(hold+=input[_in++]<<bits,bits+=8,hold+=input[_in++]<<bits,bits+=8),here=lcode[hold&lmask];dolen:for(;;){if(op=here>>>24,hold>>>=op,bits-=op,op=here>>>16&255,0===op)output[_out++]=65535&here;else{if(!(16&op)){if(0==(64&op)){here=lcode[(65535&here)+(hold&(1<<op)-1)];continue dolen}if(32&op){state.mode=12;break top}strm.msg="invalid literal/length code",state.mode=30;break top}len=65535&here,op&=15,op&&(bits<op&&(hold+=input[_in++]<<bits,bits+=8),len+=hold&(1<<op)-1,hold>>>=op,bits-=op),bits<15&&(hold+=input[_in++]<<bits,bits+=8,hold+=input[_in++]<<bits,bits+=8),here=dcode[hold&dmask];dodist:for(;;){if(op=here>>>24,hold>>>=op,bits-=op,op=here>>>16&255,!(16&op)){if(0==(64&op)){here=dcode[(65535&here)+(hold&(1<<op)-1)];continue dodist}strm.msg="invalid distance code",state.mode=30;break top}if(dist=65535&here,op&=15,bits<op&&(hold+=input[_in++]<<bits,bits+=8,bits<op&&(hold+=input[_in++]<<bits,bits+=8)),dist+=hold&(1<<op)-1,dist>dmax){strm.msg="invalid distance too far back",state.mode=30;break top}if(hold>>>=op,bits-=op,op=_out-beg,dist>op){if(op=dist-op,op>whave&&state.sane){strm.msg="invalid distance too far back",state.mode=30;break top}if(from=0,from_source=s_window,0===wnext){if(from+=wsize-op,op<len){len-=op;do{output[_out++]=s_window[from++]}while(--op);from=_out-dist,from_source=output}}else if(wnext<op){if(from+=wsize+wnext-op,op-=wnext,op<len){len-=op;do{output[_out++]=s_window[from++]}while(--op);if(from=0,wnext<len){op=wnext,len-=op;do{output[_out++]=s_window[from++]}while(--op);from=_out-dist,from_source=output}}}else if(from+=wnext-op,op<len){len-=op;do{output[_out++]=s_window[from++]}while(--op);from=_out-dist,from_source=output}for(;len>2;)output[_out++]=from_source[from++],output[_out++]=from_source[from++],output[_out++]=from_source[from++],len-=3;len&&(output[_out++]=from_source[from++],len>1&&(output[_out++]=from_source[from++]))}else{from=_out-dist;do{output[_out++]=output[from++],output[_out++]=output[from++],output[_out++]=output[from++],len-=3}while(len>2);len&&(output[_out++]=output[from++],len>1&&(output[_out++]=output[from++]))}break}}break}}while(_in<last&&_out<end);len=bits>>3,_in-=len,bits-=len<<3,hold&=(1<<bits)-1,strm.next_in=_in,strm.next_out=_out,strm.avail_in=_in<last?last-_in+5:5-(_in-last),strm.avail_out=_out<end?end-_out+257:257-(_out-end),state.hold=hold,state.bits=bits};const lbase=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),lext=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),dbase=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),dext=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]);var inftrees=(type,lens,lens_index,codes,table,table_index,work,opts)=>{const bits=opts.bits;let incr,fill,low,mask,next,end,len=0,sym=0,min=0,max=0,root=0,curr=0,drop=0,left=0,used=0,huff=0,base=null,base_index=0;const count=new Uint16Array(16),offs=new Uint16Array(16);let here_bits,here_op,here_val,extra=null,extra_index=0;for(len=0;len<=15;len++)count[len]=0;for(sym=0;sym<codes;sym++)count[lens[lens_index+sym]]++;for(root=bits,max=15;max>=1&&0===count[max];max--);if(root>max&&(root=max),0===max)return table[table_index++]=20971520,table[table_index++]=20971520,opts.bits=1,0;for(min=1;min<max&&0===count[min];min++);for(root<min&&(root=min),left=1,len=1;len<=15;len++)if(left<<=1,left-=count[len],left<0)return-1;if(left>0&&(0===type||1!==max))return-1;for(offs[1]=0,len=1;len<15;len++)offs[len+1]=offs[len]+count[len];for(sym=0;sym<codes;sym++)0!==lens[lens_index+sym]&&(work[offs[lens[lens_index+sym]]++]=sym);if(0===type?(base=extra=work,end=19):1===type?(base=lbase,base_index-=257,extra=lext,extra_index-=257,end=256):(base=dbase,extra=dext,end=-1),huff=0,sym=0,len=min,next=table_index,curr=root,drop=0,low=-1,used=1<<root,mask=used-1,1===type&&used>852||2===type&&used>592)return 1;for(;;){here_bits=len-drop,work[sym]<end?(here_op=0,here_val=work[sym]):work[sym]>end?(here_op=extra[extra_index+work[sym]],here_val=base[base_index+work[sym]]):(here_op=96,here_val=0),incr=1<<len-drop,fill=1<<curr,min=fill;do{fill-=incr,table[next+(huff>>drop)+fill]=here_bits<<24|here_op<<16|here_val|0}while(0!==fill);for(incr=1<<len-1;huff&incr;)incr>>=1;if(0!==incr?(huff&=incr-1,huff+=incr):huff=0,sym++,0==--count[len]){if(len===max)break;len=lens[lens_index+work[sym]]}if(len>root&&(huff&mask)!==low){for(0===drop&&(drop=root),next+=min,curr=len-drop,left=1<<curr;curr+drop<max&&(left-=count[curr+drop],!(left<=0));)curr++,left<<=1;if(used+=1<<curr,1===type&&used>852||2===type&&used>592)return 1;low=huff&mask,table[low]=root<<24|curr<<16|next-table_index|0}}return 0!==huff&&(table[next+huff]=len-drop<<24|64<<16|0),opts.bits=root,0};const{Z_FINISH:Z_FINISH$1,Z_BLOCK:Z_BLOCK,Z_TREES:Z_TREES,Z_OK:Z_OK$1,Z_STREAM_END:Z_STREAM_END$1,Z_NEED_DICT:Z_NEED_DICT$1,Z_STREAM_ERROR:Z_STREAM_ERROR$1,Z_DATA_ERROR:Z_DATA_ERROR$1,Z_MEM_ERROR:Z_MEM_ERROR$1,Z_BUF_ERROR:Z_BUF_ERROR,Z_DEFLATED:Z_DEFLATED}=constants$2,zswap32=q=>(q>>>24&255)+(q>>>8&65280)+((65280&q)<<8)+((255&q)<<24);function InflateState(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}const inflateResetKeep=strm=>{if(!strm||!strm.state)return Z_STREAM_ERROR$1;const state=strm.state;return strm.total_in=strm.total_out=state.total=0,strm.msg="",state.wrap&&(strm.adler=1&state.wrap),state.mode=1,state.last=0,state.havedict=0,state.dmax=32768,state.head=null,state.hold=0,state.bits=0,state.lencode=state.lendyn=new Int32Array(852),state.distcode=state.distdyn=new Int32Array(592),state.sane=1,state.back=-1,Z_OK$1},inflateReset=strm=>{if(!strm||!strm.state)return Z_STREAM_ERROR$1;const state=strm.state;return state.wsize=0,state.whave=0,state.wnext=0,inflateResetKeep(strm)},inflateReset2=(strm,windowBits)=>{let wrap;if(!strm||!strm.state)return Z_STREAM_ERROR$1;const state=strm.state;return windowBits<0?(wrap=0,windowBits=-windowBits):(wrap=1+(windowBits>>4),windowBits<48&&(windowBits&=15)),windowBits&&(windowBits<8||windowBits>15)?Z_STREAM_ERROR$1:(null!==state.window&&state.wbits!==windowBits&&(state.window=null),state.wrap=wrap,state.wbits=windowBits,inflateReset(strm))},inflateInit2=(strm,windowBits)=>{if(!strm)return Z_STREAM_ERROR$1;const state=new InflateState;strm.state=state,state.window=null;const ret=inflateReset2(strm,windowBits);return ret!==Z_OK$1&&(strm.state=null),ret};let lenfix,distfix,virgin=!0;const fixedtables=state=>{if(virgin){lenfix=new Int32Array(512),distfix=new Int32Array(32);let sym=0;for(;sym<144;)state.lens[sym++]=8;for(;sym<256;)state.lens[sym++]=9;for(;sym<280;)state.lens[sym++]=7;for(;sym<288;)state.lens[sym++]=8;for(inftrees(1,state.lens,0,288,lenfix,0,state.work,{bits:9}),sym=0;sym<32;)state.lens[sym++]=5;inftrees(2,state.lens,0,32,distfix,0,state.work,{bits:5}),virgin=!1}state.lencode=lenfix,state.lenbits=9,state.distcode=distfix,state.distbits=5},updatewindow=(strm,src,end,copy)=>{let dist;const state=strm.state;return null===state.window&&(state.wsize=1<<state.wbits,state.wnext=0,state.whave=0,state.window=new Uint8Array(state.wsize)),copy>=state.wsize?(state.window.set(src.subarray(end-state.wsize,end),0),state.wnext=0,state.whave=state.wsize):(dist=state.wsize-state.wnext,dist>copy&&(dist=copy),state.window.set(src.subarray(end-copy,end-copy+dist),state.wnext),(copy-=dist)?(state.window.set(src.subarray(end-copy,end),0),state.wnext=copy,state.whave=state.wsize):(state.wnext+=dist,state.wnext===state.wsize&&(state.wnext=0),state.whave<state.wsize&&(state.whave+=dist))),0};var inflate_1$2={inflateReset:inflateReset,inflateReset2:inflateReset2,inflateResetKeep:inflateResetKeep,inflateInit:strm=>inflateInit2(strm,15),inflateInit2:inflateInit2,inflate:(strm,flush)=>{let state,input,output,next,put,have,left,hold,bits,_in,_out,copy,from,from_source,here_bits,here_op,here_val,last_bits,last_op,last_val,len,ret,here=0;const hbuf=new Uint8Array(4);let opts,n;const order=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(!strm||!strm.state||!strm.output||!strm.input&&0!==strm.avail_in)return Z_STREAM_ERROR$1;state=strm.state,12===state.mode&&(state.mode=13),put=strm.next_out,output=strm.output,left=strm.avail_out,next=strm.next_in,input=strm.input,have=strm.avail_in,hold=state.hold,bits=state.bits,_in=have,_out=left,ret=Z_OK$1;inf_leave:for(;;)switch(state.mode){case 1:if(0===state.wrap){state.mode=13;break}for(;bits<16;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(2&state.wrap&&35615===hold){state.check=0,hbuf[0]=255&hold,hbuf[1]=hold>>>8&255,state.check=crc32_1(state.check,hbuf,2,0),hold=0,bits=0,state.mode=2;break}if(state.flags=0,state.head&&(state.head.done=!1),!(1&state.wrap)||(((255&hold)<<8)+(hold>>8))%31){strm.msg="incorrect header check",state.mode=30;break}if((15&hold)!==Z_DEFLATED){strm.msg="unknown compression method",state.mode=30;break}if(hold>>>=4,bits-=4,len=8+(15&hold),0===state.wbits)state.wbits=len;else if(len>state.wbits){strm.msg="invalid window size",state.mode=30;break}state.dmax=1<<state.wbits,strm.adler=state.check=1,state.mode=512&hold?10:12,hold=0,bits=0;break;case 2:for(;bits<16;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(state.flags=hold,(255&state.flags)!==Z_DEFLATED){strm.msg="unknown compression method",state.mode=30;break}if(57344&state.flags){strm.msg="unknown header flags set",state.mode=30;break}state.head&&(state.head.text=hold>>8&1),512&state.flags&&(hbuf[0]=255&hold,hbuf[1]=hold>>>8&255,state.check=crc32_1(state.check,hbuf,2,0)),hold=0,bits=0,state.mode=3;case 3:for(;bits<32;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}state.head&&(state.head.time=hold),512&state.flags&&(hbuf[0]=255&hold,hbuf[1]=hold>>>8&255,hbuf[2]=hold>>>16&255,hbuf[3]=hold>>>24&255,state.check=crc32_1(state.check,hbuf,4,0)),hold=0,bits=0,state.mode=4;case 4:for(;bits<16;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}state.head&&(state.head.xflags=255&hold,state.head.os=hold>>8),512&state.flags&&(hbuf[0]=255&hold,hbuf[1]=hold>>>8&255,state.check=crc32_1(state.check,hbuf,2,0)),hold=0,bits=0,state.mode=5;case 5:if(1024&state.flags){for(;bits<16;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}state.length=hold,state.head&&(state.head.extra_len=hold),512&state.flags&&(hbuf[0]=255&hold,hbuf[1]=hold>>>8&255,state.check=crc32_1(state.check,hbuf,2,0)),hold=0,bits=0}else state.head&&(state.head.extra=null);state.mode=6;case 6:if(1024&state.flags&&(copy=state.length,copy>have&&(copy=have),copy&&(state.head&&(len=state.head.extra_len-state.length,state.head.extra||(state.head.extra=new Uint8Array(state.head.extra_len)),state.head.extra.set(input.subarray(next,next+copy),len)),512&state.flags&&(state.check=crc32_1(state.check,input,copy,next)),have-=copy,next+=copy,state.length-=copy),state.length))break inf_leave;state.length=0,state.mode=7;case 7:if(2048&state.flags){if(0===have)break inf_leave;copy=0;do{len=input[next+copy++],state.head&&len&&state.length<65536&&(state.head.name+=String.fromCharCode(len))}while(len&&copy<have);if(512&state.flags&&(state.check=crc32_1(state.check,input,copy,next)),have-=copy,next+=copy,len)break inf_leave}else state.head&&(state.head.name=null);state.length=0,state.mode=8;case 8:if(4096&state.flags){if(0===have)break inf_leave;copy=0;do{len=input[next+copy++],state.head&&len&&state.length<65536&&(state.head.comment+=String.fromCharCode(len))}while(len&&copy<have);if(512&state.flags&&(state.check=crc32_1(state.check,input,copy,next)),have-=copy,next+=copy,len)break inf_leave}else state.head&&(state.head.comment=null);state.mode=9;case 9:if(512&state.flags){for(;bits<16;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(hold!==(65535&state.check)){strm.msg="header crc mismatch",state.mode=30;break}hold=0,bits=0}state.head&&(state.head.hcrc=state.flags>>9&1,state.head.done=!0),strm.adler=state.check=0,state.mode=12;break;case 10:for(;bits<32;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}strm.adler=state.check=zswap32(hold),hold=0,bits=0,state.mode=11;case 11:if(0===state.havedict)return strm.next_out=put,strm.avail_out=left,strm.next_in=next,strm.avail_in=have,state.hold=hold,state.bits=bits,Z_NEED_DICT$1;strm.adler=state.check=1,state.mode=12;case 12:if(flush===Z_BLOCK||flush===Z_TREES)break inf_leave;case 13:if(state.last){hold>>>=7&bits,bits-=7&bits,state.mode=27;break}for(;bits<3;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}switch(state.last=1&hold,hold>>>=1,bits-=1,3&hold){case 0:state.mode=14;break;case 1:if(fixedtables(state),state.mode=20,flush===Z_TREES){hold>>>=2,bits-=2;break inf_leave}break;case 2:state.mode=17;break;case 3:strm.msg="invalid block type",state.mode=30}hold>>>=2,bits-=2;break;case 14:for(hold>>>=7&bits,bits-=7&bits;bits<32;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if((65535&hold)!=(hold>>>16^65535)){strm.msg="invalid stored block lengths",state.mode=30;break}if(state.length=65535&hold,hold=0,bits=0,state.mode=15,flush===Z_TREES)break inf_leave;case 15:state.mode=16;case 16:if(copy=state.length,copy){if(copy>have&&(copy=have),copy>left&&(copy=left),0===copy)break inf_leave;output.set(input.subarray(next,next+copy),put),have-=copy,next+=copy,left-=copy,put+=copy,state.length-=copy;break}state.mode=12;break;case 17:for(;bits<14;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(state.nlen=257+(31&hold),hold>>>=5,bits-=5,state.ndist=1+(31&hold),hold>>>=5,bits-=5,state.ncode=4+(15&hold),hold>>>=4,bits-=4,state.nlen>286||state.ndist>30){strm.msg="too many length or distance symbols",state.mode=30;break}state.have=0,state.mode=18;case 18:for(;state.have<state.ncode;){for(;bits<3;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}state.lens[order[state.have++]]=7&hold,hold>>>=3,bits-=3}for(;state.have<19;)state.lens[order[state.have++]]=0;if(state.lencode=state.lendyn,state.lenbits=7,opts={bits:state.lenbits},ret=inftrees(0,state.lens,0,19,state.lencode,0,state.work,opts),state.lenbits=opts.bits,ret){strm.msg="invalid code lengths set",state.mode=30;break}state.have=0,state.mode=19;case 19:for(;state.have<state.nlen+state.ndist;){for(;here=state.lencode[hold&(1<<state.lenbits)-1],here_bits=here>>>24,here_op=here>>>16&255,here_val=65535&here,!(here_bits<=bits);){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(here_val<16)hold>>>=here_bits,bits-=here_bits,state.lens[state.have++]=here_val;else{if(16===here_val){for(n=here_bits+2;bits<n;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(hold>>>=here_bits,bits-=here_bits,0===state.have){strm.msg="invalid bit length repeat",state.mode=30;break}len=state.lens[state.have-1],copy=3+(3&hold),hold>>>=2,bits-=2}else if(17===here_val){for(n=here_bits+3;bits<n;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}hold>>>=here_bits,bits-=here_bits,len=0,copy=3+(7&hold),hold>>>=3,bits-=3}else{for(n=here_bits+7;bits<n;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}hold>>>=here_bits,bits-=here_bits,len=0,copy=11+(127&hold),hold>>>=7,bits-=7}if(state.have+copy>state.nlen+state.ndist){strm.msg="invalid bit length repeat",state.mode=30;break}for(;copy--;)state.lens[state.have++]=len}}if(30===state.mode)break;if(0===state.lens[256]){strm.msg="invalid code -- missing end-of-block",state.mode=30;break}if(state.lenbits=9,opts={bits:state.lenbits},ret=inftrees(1,state.lens,0,state.nlen,state.lencode,0,state.work,opts),state.lenbits=opts.bits,ret){strm.msg="invalid literal/lengths set",state.mode=30;break}if(state.distbits=6,state.distcode=state.distdyn,opts={bits:state.distbits},ret=inftrees(2,state.lens,state.nlen,state.ndist,state.distcode,0,state.work,opts),state.distbits=opts.bits,ret){strm.msg="invalid distances set",state.mode=30;break}if(state.mode=20,flush===Z_TREES)break inf_leave;case 20:state.mode=21;case 21:if(have>=6&&left>=258){strm.next_out=put,strm.avail_out=left,strm.next_in=next,strm.avail_in=have,state.hold=hold,state.bits=bits,inffast(strm,_out),put=strm.next_out,output=strm.output,left=strm.avail_out,next=strm.next_in,input=strm.input,have=strm.avail_in,hold=state.hold,bits=state.bits,12===state.mode&&(state.back=-1);break}for(state.back=0;here=state.lencode[hold&(1<<state.lenbits)-1],here_bits=here>>>24,here_op=here>>>16&255,here_val=65535&here,!(here_bits<=bits);){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(here_op&&0==(240&here_op)){for(last_bits=here_bits,last_op=here_op,last_val=here_val;here=state.lencode[last_val+((hold&(1<<last_bits+last_op)-1)>>last_bits)],here_bits=here>>>24,here_op=here>>>16&255,here_val=65535&here,!(last_bits+here_bits<=bits);){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}hold>>>=last_bits,bits-=last_bits,state.back+=last_bits}if(hold>>>=here_bits,bits-=here_bits,state.back+=here_bits,state.length=here_val,0===here_op){state.mode=26;break}if(32&here_op){state.back=-1,state.mode=12;break}if(64&here_op){strm.msg="invalid literal/length code",state.mode=30;break}state.extra=15&here_op,state.mode=22;case 22:if(state.extra){for(n=state.extra;bits<n;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}state.length+=hold&(1<<state.extra)-1,hold>>>=state.extra,bits-=state.extra,state.back+=state.extra}state.was=state.length,state.mode=23;case 23:for(;here=state.distcode[hold&(1<<state.distbits)-1],here_bits=here>>>24,here_op=here>>>16&255,here_val=65535&here,!(here_bits<=bits);){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(0==(240&here_op)){for(last_bits=here_bits,last_op=here_op,last_val=here_val;here=state.distcode[last_val+((hold&(1<<last_bits+last_op)-1)>>last_bits)],here_bits=here>>>24,here_op=here>>>16&255,here_val=65535&here,!(last_bits+here_bits<=bits);){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}hold>>>=last_bits,bits-=last_bits,state.back+=last_bits}if(hold>>>=here_bits,bits-=here_bits,state.back+=here_bits,64&here_op){strm.msg="invalid distance code",state.mode=30;break}state.offset=here_val,state.extra=15&here_op,state.mode=24;case 24:if(state.extra){for(n=state.extra;bits<n;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}state.offset+=hold&(1<<state.extra)-1,hold>>>=state.extra,bits-=state.extra,state.back+=state.extra}if(state.offset>state.dmax){strm.msg="invalid distance too far back",state.mode=30;break}state.mode=25;case 25:if(0===left)break inf_leave;if(copy=_out-left,state.offset>copy){if(copy=state.offset-copy,copy>state.whave&&state.sane){strm.msg="invalid distance too far back",state.mode=30;break}copy>state.wnext?(copy-=state.wnext,from=state.wsize-copy):from=state.wnext-copy,copy>state.length&&(copy=state.length),from_source=state.window}else from_source=output,from=put-state.offset,copy=state.length;copy>left&&(copy=left),left-=copy,state.length-=copy;do{output[put++]=from_source[from++]}while(--copy);0===state.length&&(state.mode=21);break;case 26:if(0===left)break inf_leave;output[put++]=state.length,left--,state.mode=21;break;case 27:if(state.wrap){for(;bits<32;){if(0===have)break inf_leave;have--,hold|=input[next++]<<bits,bits+=8}if(_out-=left,strm.total_out+=_out,state.total+=_out,_out&&(strm.adler=state.check=state.flags?crc32_1(state.check,output,_out,put-_out):adler32_1(state.check,output,_out,put-_out)),_out=left,(state.flags?hold:zswap32(hold))!==state.check){strm.msg="incorrect data check",state.mode=30;break}hold=0,bits=0}state.mode=28;case 28:if(state.wrap&&state.flags){for(;bits<32;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(hold!==(4294967295&state.total)){strm.msg="incorrect length check",state.mode=30;break}hold=0,bits=0}state.mode=29;case 29:ret=Z_STREAM_END$1;break inf_leave;case 30:ret=Z_DATA_ERROR$1;break inf_leave;case 31:return Z_MEM_ERROR$1;default:return Z_STREAM_ERROR$1}return strm.next_out=put,strm.avail_out=left,strm.next_in=next,strm.avail_in=have,state.hold=hold,state.bits=bits,(state.wsize||_out!==strm.avail_out&&state.mode<30&&(state.mode<27||flush!==Z_FINISH$1))&&updatewindow(strm,strm.output,strm.next_out,_out-strm.avail_out),_in-=strm.avail_in,_out-=strm.avail_out,strm.total_in+=_in,strm.total_out+=_out,state.total+=_out,state.wrap&&_out&&(strm.adler=state.check=state.flags?crc32_1(state.check,output,_out,strm.next_out-_out):adler32_1(state.check,output,_out,strm.next_out-_out)),strm.data_type=state.bits+(state.last?64:0)+(12===state.mode?128:0)+(20===state.mode||15===state.mode?256:0),(0===_in&&0===_out||flush===Z_FINISH$1)&&ret===Z_OK$1&&(ret=Z_BUF_ERROR),ret},inflateEnd:strm=>{if(!strm||!strm.state)return Z_STREAM_ERROR$1;let state=strm.state;return state.window&&(state.window=null),strm.state=null,Z_OK$1},inflateGetHeader:(strm,head)=>{if(!strm||!strm.state)return Z_STREAM_ERROR$1;const state=strm.state;return 0==(2&state.wrap)?Z_STREAM_ERROR$1:(state.head=head,head.done=!1,Z_OK$1)},inflateSetDictionary:(strm,dictionary)=>{const dictLength=dictionary.length;let state,dictid,ret;return strm&&strm.state?(state=strm.state,0!==state.wrap&&11!==state.mode?Z_STREAM_ERROR$1:11===state.mode&&(dictid=1,dictid=adler32_1(dictid,dictionary,dictLength,0),dictid!==state.check)?Z_DATA_ERROR$1:(ret=updatewindow(strm,dictionary,dictLength,dictLength),ret?(state.mode=31,Z_MEM_ERROR$1):(state.havedict=1,Z_OK$1))):Z_STREAM_ERROR$1},inflateInfo:"pako inflate (from Nodeca project)"};var gzheader=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1};const toString=Object.prototype.toString,{Z_NO_FLUSH:Z_NO_FLUSH,Z_FINISH:Z_FINISH,Z_OK:Z_OK,Z_STREAM_END:Z_STREAM_END,Z_NEED_DICT:Z_NEED_DICT,Z_STREAM_ERROR:Z_STREAM_ERROR,Z_DATA_ERROR:Z_DATA_ERROR,Z_MEM_ERROR:Z_MEM_ERROR}=constants$2;function Inflate$1(options){this.options=common_assign({chunkSize:65536,windowBits:15,to:""},options||{});const opt=this.options;opt.raw&&opt.windowBits>=0&&opt.windowBits<16&&(opt.windowBits=-opt.windowBits,0===opt.windowBits&&(opt.windowBits=-15)),!(opt.windowBits>=0&&opt.windowBits<16)||options&&options.windowBits||(opt.windowBits+=32),opt.windowBits>15&&opt.windowBits<48&&0==(15&opt.windowBits)&&(opt.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new zstream,this.strm.avail_out=0;let status=inflate_1$2.inflateInit2(this.strm,opt.windowBits);if(status!==Z_OK)throw new Error(messages[status]);if(this.header=new gzheader,inflate_1$2.inflateGetHeader(this.strm,this.header),opt.dictionary&&("string"==typeof opt.dictionary?opt.dictionary=strings_string2buf(opt.dictionary):"[object ArrayBuffer]"===toString.call(opt.dictionary)&&(opt.dictionary=new Uint8Array(opt.dictionary)),opt.raw&&(status=inflate_1$2.inflateSetDictionary(this.strm,opt.dictionary),status!==Z_OK)))throw new Error(messages[status])}function inflate$1(input,options){const inflator=new Inflate$1(options);if(inflator.push(input),inflator.err)throw inflator.msg||messages[inflator.err];return inflator.result}Inflate$1.prototype.push=function(data,flush_mode){const strm=this.strm,chunkSize=this.options.chunkSize,dictionary=this.options.dictionary;let status,_flush_mode,last_avail_out;if(this.ended)return!1;for(_flush_mode=flush_mode===~~flush_mode?flush_mode:!0===flush_mode?Z_FINISH:Z_NO_FLUSH,"[object ArrayBuffer]"===toString.call(data)?strm.input=new Uint8Array(data):strm.input=data,strm.next_in=0,strm.avail_in=strm.input.length;;){for(0===strm.avail_out&&(strm.output=new Uint8Array(chunkSize),strm.next_out=0,strm.avail_out=chunkSize),status=inflate_1$2.inflate(strm,_flush_mode),status===Z_NEED_DICT&&dictionary&&(status=inflate_1$2.inflateSetDictionary(strm,dictionary),status===Z_OK?status=inflate_1$2.inflate(strm,_flush_mode):status===Z_DATA_ERROR&&(status=Z_NEED_DICT));strm.avail_in>0&&status===Z_STREAM_END&&strm.state.wrap>0&&0!==data[strm.next_in];)inflate_1$2.inflateReset(strm),status=inflate_1$2.inflate(strm,_flush_mode);switch(status){case Z_STREAM_ERROR:case Z_DATA_ERROR:case Z_NEED_DICT:case Z_MEM_ERROR:return this.onEnd(status),this.ended=!0,!1}if(last_avail_out=strm.avail_out,strm.next_out&&(0===strm.avail_out||status===Z_STREAM_END))if("string"===this.options.to){let next_out_utf8=strings_utf8border(strm.output,strm.next_out),tail=strm.next_out-next_out_utf8,utf8str=strings_buf2string(strm.output,next_out_utf8);strm.next_out=tail,strm.avail_out=chunkSize-tail,tail&&strm.output.set(strm.output.subarray(next_out_utf8,next_out_utf8+tail),0),this.onData(utf8str)}else this.onData(strm.output.length===strm.next_out?strm.output:strm.output.subarray(0,strm.next_out));if(status!==Z_OK||0!==last_avail_out){if(status===Z_STREAM_END)return status=inflate_1$2.inflateEnd(this.strm),this.onEnd(status),this.ended=!0,!0;if(0===strm.avail_in)break}}return!0},Inflate$1.prototype.onData=function(chunk){this.chunks.push(chunk)},Inflate$1.prototype.onEnd=function(status){status===Z_OK&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=common_flattenChunks(this.chunks)),this.chunks=[],this.err=status,this.msg=this.strm.msg};var inflate_1$1={Inflate:Inflate$1,inflate:inflate$1,inflateRaw:function(input,options){return(options=options||{}).raw=!0,inflate$1(input,options)},ungzip:inflate$1,constants:constants$2};const{Deflate:Deflate,deflate:deflate,deflateRaw:deflateRaw,gzip:gzip}=deflate_1$1,{Inflate:Inflate,inflate:inflate,inflateRaw:inflateRaw,ungzip:ungzip}=inflate_1$1;var pako={Deflate:Deflate,deflate:deflate,deflateRaw:deflateRaw,gzip:gzip,Inflate:Inflate,inflate:inflate,inflateRaw:inflateRaw,ungzip:ungzip,constants:constants$2},max=1e13;class Int10{buf;constructor(value){this.buf=[+value||0]}mulAdd(m,c){var i,t,b=this.buf,l=b.length;for(i=0;i<l;++i)(t=b[i]*m+c)<max?c=0:t-=(c=0|t/max)*max,b[i]=t;c>0&&(b[i]=c)}sub(c){var i,t,b=this.buf,l=b.length;for(i=0;i<l;++i)(t=b[i]-c)<0?(t+=max,c=1):c=0,b[i]=t;for(;0===b[b.length-1];)b.pop()}toString(base){if(10!=(base||10))throw"only base 10 is supported";for(var b=this.buf,s=b[b.length-1].toString(),i=b.length-2;i>=0;--i)s+=(max+b[i]).toString().substring(1);return s}valueOf(){for(var b=this.buf,v=0,i=b.length-1;i>=0;--i)v=v*max+b[i];return v}simplify(){var b=this.buf;return 1==b.length?b[0]:this}}const UNSUPPORTED_ALGORITHM='Unsupported algorithm name specified! Supported algorithms: "HS256", "HS384", "HS512", "RS256", "RS384", "RS512" and "none".',ILLEGAL_ARGUMENT="Illegal argument specified!";function generateErrorMessage(value,callee,argumentName="argument",defaultType="string"){let message=`Invalid argument passed to ${callee}.`;return typeof value!==defaultType?message+=` Expected type '${defaultType}', received '${typeof value}'.`:value?"argument"!==argumentName&&(message+=` Provided ${argumentName} is invalid.`):message+=` Provided ${argumentName} is empty.`,message}function cleanZeros(b){return 0===b[0]?cleanZeros(b.slice(1)):b}function hex2AB(hex){if(!hex)throw new Error(ILLEGAL_ARGUMENT);const match=hex.match(/[0-9A-F]{2}/gi);if(!match)throw new Error(ILLEGAL_ARGUMENT);return new Uint8Array(match.map((i=>parseInt(i,16))))}const reTimeS=/^(\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/,reTimeL=/^(\d\d\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/;function stringCut(str,len){return str.length>len&&(str=str.substring(0,len)+""),str}class Stream{enc;pos;constructor(enc,pos=0){enc instanceof Stream?(this.enc=enc.enc,this.pos=enc.pos):(this.enc=enc,this.pos=pos)}get(pos){if(void 0===pos&&(pos=this.pos++),pos>=this.enc.length)throw"Requesting byte offset "+pos+" on a stream of length "+this.enc.length;return"string"==typeof this.enc?this.enc.charCodeAt(pos):this.enc[pos]}hexDigits="0123456789ABCDEF";hexByte(b){return this.hexDigits.charAt(b>>4&15)+this.hexDigits.charAt(15&b)}hexDump(start,end,raw){for(var s="",i=start;i<end;++i)if(s+=this.hexByte(this.get(i)),!0!==raw)switch(15&i){case 7:s+="  ";break;case 15:s+="\n";break;default:s+=" "}return s}isASCII(start,end){for(var i=start;i<end;++i){var c=this.get(i);if(c<32||c>176)return!1}return!0}parseStringISO(start,end){for(var s="",i=start;i<end;++i)s+=String.fromCharCode(this.get(i));return s}parseStringUTF(start,end){for(var s="",i=start;i<end;){var c=this.get(i++);s+=c<128?String.fromCharCode(c):c>191&&c<224?String.fromCharCode((31&c)<<6|63&this.get(i++)):String.fromCharCode((15&c)<<12|(63&this.get(i++))<<6|63&this.get(i++))}return s}parseStringBMP(start,end){for(var hi,lo,str="",i=start;i<end;)hi=this.get(i++),lo=this.get(i++),str+=String.fromCharCode(hi<<8|lo);return str}parseTime(start,end,shortYear){var s=this.parseStringISO(start,end),m=(shortYear?reTimeS:reTimeL).exec(s);if(!m)return"Unrecognized time: "+s;if(shortYear){var y=+m[1]<70?2e3:1900;m[1]=y+""}return s=m[1]+"-"+m[2]+"-"+m[3]+" "+m[4],m[5]&&(s+=":"+m[5],m[6]&&(s+=":"+m[6],m[7]&&(s+="."+m[7]))),m[8]&&(s+=" UTC","Z"!=m[8]&&(s+=m[8],m[9]&&(s+=":"+m[9]))),s}parseInteger(start,end){for(var len,v=this.get(start),neg=v>127,pad=neg?255:0,s="";v==pad&&++start<end;)v=this.get(start);if(0===(len=end-start))return neg?-1:0;if(len>4){let t=+v;for(len<<=3;0==(128&(t^pad));)t<<=1,--len;s="("+len+" bit)\n"}neg&&(v-=256);const n=new Int10(v);for(let i=start+1;i<end;++i)n.mulAdd(256,this.get(i));return s+n.toString()}parseBitString(start,end,maxLength){for(var unusedBit=this.get(start),intro="("+((end-start-1<<3)-unusedBit)+" bit)\n",s="",i=start+1;i<end;++i){for(var b=this.get(i),skip=i==end-1?unusedBit:0,j=7;j>=skip;--j)s+=b>>j&1?"1":"0";if(s.length>maxLength)return intro+stringCut(s,maxLength)}return intro+s}parseOctetString(start,end,maxLength){if(this.isASCII(start,end))return stringCut(this.parseStringISO(start,end),maxLength);var len=end-start,s="("+len+" byte)\n";len>(maxLength/=2)&&(end=start+maxLength);for(var i=start;i<end;++i)s+=this.hexByte(this.get(i));return len>maxLength&&(s+=""),s}parseOID(start,end,maxLength){for(var s="",n=new Int10,bits=0,i=start;i<end;++i){var v=this.get(i);if(n.mulAdd(128,127&v),bits+=7,!(128&v)){if(""===s)if((n=n.simplify())instanceof Int10)n.sub(80),s="2."+n.toString();else{var m=n<80?n<40?0:1:2;s=m+"."+(n-40*m)}else s+="."+n.toString();if(s.length>maxLength)return stringCut(s,maxLength);n=new Int10,bits=0}}return bits>0&&(s+=".incomplete"),s}}class ASN1{stream;header;length;tag;sub;constructor(stream,header,length,tag,sub){if(!(tag instanceof ASN1Tag))throw"Invalid tag value.";this.stream=stream,this.header=header,this.length=length,this.tag=tag,this.sub=sub}typeName(){switch(this.tag.tagClass){case 0:switch(this.tag.tagNumber){case 0:return"EOC";case 1:return"BOOLEAN";case 2:return"INTEGER";case 3:return"BIT_STRING";case 4:return"OCTET_STRING";case 5:return"NULL";case 6:return"OBJECT_IDENTIFIER";case 7:return"ObjectDescriptor";case 8:return"EXTERNAL";case 9:return"REAL";case 10:return"ENUMERATED";case 11:return"EMBEDDED_PDV";case 12:return"UTF8String";case 16:return"SEQUENCE";case 17:return"SET";case 18:return"NumericString";case 19:return"PrintableString";case 20:return"TeletexString";case 21:return"VideotexString";case 22:return"IA5String";case 23:return"UTCTime";case 24:return"GeneralizedTime";case 25:return"GraphicString";case 26:return"VisibleString";case 27:return"GeneralString";case 28:return"UniversalString";case 30:return"BMPString"}return"Universal_"+this.tag.tagNumber.toString();case 1:return"Application_"+this.tag.tagNumber.toString();case 2:return"["+this.tag.tagNumber.toString()+"]";case 3:return"Private_"+this.tag.tagNumber.toString()}}content(maxLength){if(void 0===this.tag)return null;void 0===maxLength&&(maxLength=1/0);var content=this.posContent(),len=Math.abs(this.length);if(!this.tag.isUniversal())return null!==this.sub?"("+this.sub.length+" elem)":this.stream.parseOctetString(content,content+len,maxLength);switch(this.tag.tagNumber){case 1:return 0===this.stream.get(content)?"false":"true";case 2:return this.stream.parseInteger(content,content+len);case 3:return this.sub?"("+this.sub.length+" elem)":this.stream.parseBitString(content,content+len,maxLength);case 4:return this.sub?"("+this.sub.length+" elem)":this.stream.parseOctetString(content,content+len,maxLength);case 6:return this.stream.parseOID(content,content+len,maxLength);case 16:case 17:return null!==this.sub?"("+this.sub.length+" elem)":"(no elem)";case 12:return stringCut(this.stream.parseStringUTF(content,content+len),maxLength);case 18:case 19:case 20:case 21:case 22:case 26:return stringCut(this.stream.parseStringISO(content,content+len),maxLength);case 30:return stringCut(this.stream.parseStringBMP(content,content+len),maxLength);case 23:case 24:return this.stream.parseTime(content,content+len,23==this.tag.tagNumber)}return null}toString(){return this.typeName()+"@"+this.stream.pos+"[header:"+this.header+",length:"+this.length+",sub:"+(null===this.sub?"null":this.sub.length)+"]"}posStart(){return this.stream.pos}posContent(){return this.stream.pos+this.header}posEnd(){return this.stream.pos+this.header+Math.abs(this.length)}toHexString(root){return this.stream.hexDump(this.posStart(),this.posEnd(),!0)}getHex(){return this.stream.hexDump(this.posContent(),this.posEnd(),!0)}getAB(clean=!0){return clean?cleanZeros(hex2AB(this.getHex())):hex2AB(this.getHex())}static decodeLength(stream){let buf=stream.get();const len=127&buf;if(len==buf)return len;if(len>6)throw"Length over 48 bits not supported at position "+(stream.pos-1);if(0===len)return null;buf=0;for(var i=0;i<len;++i)buf=256*buf+stream.get();return buf}static decode(stream){stream instanceof Stream||(stream=new Stream(stream,0));const streamStart=new Stream(stream),tag=new ASN1Tag(stream);let len=ASN1.decodeLength(stream),sub=null;const start=stream.pos,header=start-streamStart.pos,getSub=function(){if(sub=[],null!==len){for(var end=start+len;stream.pos<end;)sub[sub.length]=ASN1.decode(stream);if(stream.pos!=end)throw"Content size is not correct for container starting at offset "+start}else try{for(;;){const s=ASN1.decode(stream);if(s.tag.isEOC())break;sub[sub.length]=s}len=start-stream.pos}catch(e){throw"Exception while decoding undefined length content: "+e}};if(tag.tagConstructed)getSub();else if(tag.isUniversal()&&(3==tag.tagNumber||4==tag.tagNumber))try{if(3==tag.tagNumber&&0!=stream.get())throw"BIT STRINGs with unused bits cannot encapsulate.";getSub();for(var i=0;i<sub.length;++i)if(sub[i].tag.isEOC())throw"EOC is not supposed to be actual content."}catch(e){sub=null}if(null===sub){if(null===len)throw"We can't skip over an invalid tag with undefined length at offset "+start;stream.pos=start+Math.abs(len)}return new ASN1(streamStart,header,len,tag,sub)}}class ASN1Tag{tagClass;tagConstructed;tagNumber;constructor(stream){var buf=stream.get();if(this.tagClass=buf>>6,this.tagConstructed=0!=(32&buf),this.tagNumber=31&buf,31==this.tagNumber){var n=new Int10;do{buf=stream.get(),n.mulAdd(128,127&buf)}while(128&buf);this.tagNumber=n.simplify()}}isUniversal(){return 0===this.tagClass}isEOC(){return 0===this.tagClass&&0===this.tagNumber}}const webCrypto="object"==typeof window&&(window.crypto||window.msCrypto),webCryptoSubtle=webCrypto&&(webCrypto.subtle||webCrypto.webkitSubtle||webCrypto.Subtle);class JwtSplit{header;payload;signature;constructor(str,callee="JwtSplit"){if("string"!=typeof str)throw new Error(generateErrorMessage(str,callee,"JWT string"));const jwtArr=str.split(".");if(3!==jwtArr.length)throw new Error(generateErrorMessage(str,callee,"JWT string"));const[header,payload,signature]=jwtArr;this.header=header,this.payload=payload,this.signature=signature}toString(){return this.header+"."+this.payload+"."+this.signature}}class JwtDecode{header={};payload={};signature="";constructor(str,callee="JwtDecode"){if("string"!=typeof str)throw new Error(generateErrorMessage(str,callee,"JWT string"));const jwtObj=jwtSplit(str,callee);jwtObj&&(this.header=jwtObj.header?s2J(bu2s(jwtObj.header)):{},this.payload=jwtObj.payload?isGzip(this.header)?s2J(zbu2s(jwtObj.payload)):s2J(bu2s(jwtObj.payload)):{},this.signature=jwtObj.signature||"")}toString(){return s2bu(J2s(this.header))+"."+(isGzip(this.header)?s2zbu(J2s(this.payload)):s2bu(J2s(this.payload)))+"."+this.signature}}function tryPromise(fn){try{return Promise.resolve(fn())}catch(e){return Promise.reject(e)}}function s2J(str){try{return JSON.parse(str)}catch(e){throw e}}function J2s(obj){try{return JSON.stringify(obj)}catch(e){throw e}}function b2s(str){try{if("object"==typeof window&&"function"==typeof window.atob)return window.atob(str);if("undefined"!=typeof Buffer)return Buffer.from(str,"base64").toString("binary");throw new Error(ILLEGAL_ARGUMENT)}catch(e){throw e}}function b2bu(str){if("string"!=typeof str||str.length%4!=0)throw new Error(ILLEGAL_ARGUMENT);return str.replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function bu2b(str){if("string"!=typeof str||str.length%4==1)throw new Error(ILLEGAL_ARGUMENT);for(;str.length%4!=0;)str+="=";return str.replace(/\-/g,"+").replace(/_/g,"/")}function bu2s(str){return b2s(bu2b(str))}function isGzip(header){return"object"==typeof header&&"string"==typeof header.zip&&"GZIP"===header.zip.toUpperCase()}function jwtDecode(str,callee="jwtDecode"){return new JwtDecode(str,callee)}function jwtSplit(str,callee="jwtSplit"){return new JwtSplit(str,callee)}const splitJwt=jwtSplit;function s2b(str){try{if("object"==typeof window&&"function"==typeof window.btoa)return window.btoa(str);if("undefined"!=typeof Buffer)return Buffer.from(str).toString("base64");throw new Error(ILLEGAL_ARGUMENT)}catch(e){throw e}}function s2bu(str){return b2bu(s2b(str))}function s2zbu(str){return s2bu(zip(str))}function unzip(str){if("string"!=typeof str)throw new Error(ILLEGAL_ARGUMENT);if(pako&&pako.inflate)return AB2s(pako.inflate(s2AB(str),{raw:!1}));throw new Error("Could not find 'pako'.")}function zbu2s(str){return unzip(bu2s(str))}function zip(str){if("string"!=typeof str)throw new Error(ILLEGAL_ARGUMENT);if(pako&&pako.deflate)return AB2s(pako.deflate(str,{raw:!1}));throw new Error("Could not find 'pako'.")}function s2AB(str){const buff=new ArrayBuffer(str.length),view=new Uint8Array(buff);for(let i=0;i<str.length;i++)view[i]=str.charCodeAt(i);return buff}function AB2s(buff){return buff instanceof Uint8Array||(buff=new Uint8Array(buff)),String.fromCharCode.apply(String,Array.from(buff))}async function createHmac(name,secret){if(webCryptoSubtle){const keyData=s2AB(secret);return await webCryptoSubtle.importKey("raw",keyData,{name:"HMAC",hash:{name:name}},!0,["sign"]).then((key=>({update:async function(thing){return await webCryptoSubtle.sign("HMAC",key,s2AB(thing))}})))}{const crypto=await import("crypto");return crypto&&crypto.createHmac?Promise.resolve(crypto.createHmac(name.replace("SHA-","sha"),secret)):Promise.reject(webCrypto)}}function algHSsign(bits){return async function(thing,secret){const hmac=await createHmac("SHA-"+bits,secret);return webCryptoSubtle?hmac?Promise.resolve(s2bu(AB2s(await hmac.update(thing)))):Promise.reject(ILLEGAL_ARGUMENT):Promise.resolve(b2bu(hmac.update(thing).digest("base64")))}}function algHSverify(bits){return async function(thing,signature,secret){return await algHSsign(bits)(thing,secret)===signature}}function s2pem(secret){if("string"!=typeof secret)throw new Error(ILLEGAL_ARGUMENT);let type="public";const lines=secret.split("\n"),ignoreLinesPriv=["-BEGIN RSA PRIVATE KEY-","-END RSA PRIVATE KEY-"],ignoreLinesPub=["-BEGIN RSA PUBLIC KEY-","-BEGIN PUBLIC KEY-","-END PUBLIC KEY-","-END RSA PUBLIC KEY-"],body=lines.map((line=>line.trim())).filter((line=>line.length&&function(line){return ignoreLinesPriv.some((ign=>line.toUpperCase().indexOf(ign)>-1))?(type="private",!1):!ignoreLinesPub.some((ign=>line.toUpperCase().indexOf(ign)>-1))}(line))).join("");if(body.length)return{body:s2AB(b2s(bu2b(body))),type:type};throw new Error(ILLEGAL_ARGUMENT)}function pem2asn1(buff){if(!buff)throw new Error(ILLEGAL_ARGUMENT);buff instanceof ArrayBuffer&&(buff=new Uint8Array(buff));let asn1=ASN1.decode(buff),res={};if(3===asn1.sub.length&&(asn1=asn1.sub[2].sub[0]),9===asn1.sub.length?(res.modulus=asn1.sub[1].getAB(),res.publicExponent=parseInt(asn1.sub[2].getHex(),16),res.privateExponent=asn1.sub[3].getAB(),res.prime1=asn1.sub[4].getAB(),res.prime2=asn1.sub[5].getAB(),res.exponent1=asn1.sub[6].getAB(),res.exponent2=asn1.sub[7].getAB(),res.coefficient=asn1.sub[8].getAB()):2===asn1.sub.length&&(asn1=asn1.sub[1].sub[0],res.modulus=asn1.sub[0].getAB(),res.publicExponent=parseInt(asn1.sub[1].getHex(),16)),res.bits=8*(res.modulus.length-1)+Math.ceil(Math.log(res.modulus[0]+1)/Math.log(2)),!res.bits)throw new Error(ILLEGAL_ARGUMENT);return res}function asn12jwk(asn1,type,extra){if(!asn1)throw new Error(ILLEGAL_ARGUMENT);if("private"===(type="string"==typeof type&&type.toLowerCase()||["public","private"][asn1.privateExponent?1:0])&&!asn1.privateExponent)throw new Error(ILLEGAL_ARGUMENT);let v=asn1.publicExponent;const expSize=Math.ceil(Math.log(v)/Math.log(256)),exp=new Uint8Array(expSize).map((function(el){return el=v%256,v=Math.floor(v/256),el})).reverse();let jwk=Object.assign({kty:"RSA"},extra,{n:s2bu(AB2s(asn1.modulus)),e:s2bu(AB2s(exp))});return"private"===type&&Object.assign(jwk,{d:s2bu(AB2s(asn1.privateExponent)),p:s2bu(AB2s(asn1.prime1)),q:s2bu(AB2s(asn1.prime2)),dp:s2bu(AB2s(asn1.exponent1)),dq:s2bu(AB2s(asn1.exponent2)),qi:s2bu(AB2s(asn1.coefficient))}),jwk}function pem2jwk(secret,type,extra){return tryPromise((()=>asn12jwk(pem2asn1(s2pem(secret).body),type,extra)))}async function createSign(name){if(webCryptoSubtle)return{update:function(thing){return{sign:async function(secret,encoding){return await pem2jwk(secret,"private",{key_ops:["sign"],alg:name.replace("SHA-","RS")}).then((async keyData=>await webCryptoSubtle.importKey("jwk",keyData,{name:"RSASSA-PKCS1-v1_5",hash:{name:name}},!0,["sign"]).then((async key=>await webCryptoSubtle.sign({name:"RSASSA-PKCS1-v1_5",hash:{name:name}},key,s2AB(thing)).then(AB2s).then(s2b)))))}}}};{const crypto=await import("crypto");if(crypto&&crypto.createSign)return crypto.createSign(name.replace("SHA-","RSA-SHA"));throw new Error("Could not find 'crypto'.")}}function algRSsign(bits){return async function(thing,privateKey){try{const res=await createSign("SHA-"+bits);return b2bu(await res.update(thing).sign(privateKey,"base64"))}catch(e){return Promise.reject(e)}}}async function createVerify(name){if(webCryptoSubtle)return{update:function(thing){return{verify:async function(secret,signature,encoding){return await pem2jwk(secret,"public",{key_ops:["verify"],alg:name.replace("SHA-","RS")}).then((async({kty:kty,n:n,e:e})=>await webCryptoSubtle.importKey("jwk",{kty:kty,n:n,e:e},{name:"RSASSA-PKCS1-v1_5",hash:{name:name}},!1,["verify"]).then((async key=>await webCryptoSubtle.verify("RSASSA-PKCS1-v1_5",key,s2AB(bu2s(signature)),s2AB(thing))))))}}}};{const crypto=await import("crypto");if(crypto&&crypto.createVerify)return crypto.createVerify(name.replace("SHA-","RSA-SHA"));throw new Error("Could not find 'crypto'.")}}function algRSverify(bits){return async function(thing,signature,publicKey){try{signature=bu2b(signature);const rsaVerify=await createVerify("SHA-"+bits);return await rsaVerify.update(thing).verify(publicKey,signature,"base64")}catch(e){return Promise.reject(e)}}}async function algVerify(algorithm,thing,signature,secret){if("string"!=typeof algorithm||algorithm.length<4)throw new Error(UNSUPPORTED_ALGORITHM);const algo=algorithm.toLowerCase();if("none"===algo)return""===signature;const type=algo.slice(0,2),bits=parseInt(algo.slice(2));if(isNaN(bits)||[256,384,512].indexOf(bits)<0)throw new Error(UNSUPPORTED_ALGORITHM);switch(type){case"rs":return await algRSverify(bits)(thing,signature,secret);case"hs":return await algHSverify(bits)(thing,signature,secret);default:throw new Error(UNSUPPORTED_ALGORITHM)}}async function algSign(algorithm,thing,secret){if("string"!=typeof algorithm||algorithm.length<4)throw new Error(UNSUPPORTED_ALGORITHM);const algo=algorithm.toLowerCase();if("none"===algo)return"";const type=algo.slice(0,2),bits=parseInt(algo.slice(2));if(isNaN(bits)||[256,384,512].indexOf(bits)<0)throw new Error(UNSUPPORTED_ALGORITHM);switch(type){case"rs":return await algRSsign(bits)(thing,secret);case"hs":return await algHSsign(bits)(thing,secret);default:throw new Error(UNSUPPORTED_ALGORITHM)}}async function jwtVerify(jwtStr,secret){const jwt=jwtSplit(jwtStr,"jwtVerify"),header=s2J(bu2s(jwt.header)),thing=jwt.header+"."+jwt.payload;return tryPromise((()=>algVerify(header.alg,thing,jwt.signature,secret)))}const verifyJwt=jwtVerify;function jwtSign(jwtStr,secret){const jwt=jwtSplit(jwtStr,"jwtSign"),header=s2J(bu2s(jwt.header)),thing=jwt.header+"."+jwt.payload;return tryPromise((async()=>await algSign(header.alg,thing,secret)))}const signJwt=jwtSign;async function jwtResign(jwtStr,secret,alg){const jwt=jwtDecode(jwtStr,"jwtResign");return alg&&(jwt.header.alg=alg),jwt.signature=await jwtSign(jwt.toString(),secret),jwt.toString()}const resignJwt=jwtResign;return exports.AB2s=AB2s,exports.Asn1Tag=class{tagClass=0;tagConstructed=!1;tagNumber=0;constructor(stream){const buf=stream.read();this.tagClass=buf>>6,this.tagConstructed=0!=(32&buf),this.tagNumber=31&buf}},exports.J2s=J2s,exports.JwtDecode=JwtDecode,exports.JwtSplit=JwtSplit,exports.algHSsign=algHSsign,exports.algHSverify=algHSverify,exports.algRSsign=algRSsign,exports.algRSverify=algRSverify,exports.algSign=algSign,exports.algVerify=algVerify,exports.asn12jwk=asn12jwk,exports.b2bu=b2bu,exports.b2s=b2s,exports.bu2b=bu2b,exports.bu2s=bu2s,exports.createHmac=createHmac,exports.createSign=createSign,exports.createVerify=createVerify,exports.cryptoType=async function(){const crypto=webCrypto||await import("crypto");return crypto?crypto.type||"crypto-node":"undefined"},exports.isGzip=isGzip,exports.jwtDecode=jwtDecode,exports.jwtResign=jwtResign,exports.jwtSign=jwtSign,exports.jwtSplit=jwtSplit,exports.jwtVerify=jwtVerify,exports.pem2asn1=pem2asn1,exports.pem2jwk=pem2jwk,exports.resignJwt=resignJwt,exports.s2AB=s2AB,exports.s2J=s2J,exports.s2b=s2b,exports.s2bu=s2bu,exports.s2pem=s2pem,exports.s2zbu=s2zbu,exports.signJwt=signJwt,exports.splitJwt=splitJwt,exports.tryPromise=tryPromise,exports.unzip=unzip,exports.verifyJwt=verifyJwt,exports.webCrypto=webCrypto,exports.webCryptoSubtle=webCryptoSubtle,exports.zbu2s=zbu2s,exports.zip=zip,Object.defineProperty(exports,"__esModule",{value:!0}),exports}({});
