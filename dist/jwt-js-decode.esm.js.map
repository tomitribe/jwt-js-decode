{"version":3,"file":"jwt-js-decode.esm.js","sources":["../src/jwt-js-decode.ts"],"sourcesContent":["import pako from \"pako\";\r\nimport crypto from \"crypto\";\r\n/*\r\nbrowserify\r\nimport { createHmac, createSign, createVerify } from \"crypto-browserify\";\r\n\r\nnode.js\r\nimport { createHmac, createSign, createVerify } from \"crypto\";\r\n*/\r\nexport const webCrypto = typeof window === \"object\" && (window.crypto || window['msCrypto']);\r\nexport const webCryptoSubtle = webCrypto && (webCrypto.subtle ||  webCrypto['webkitSubtle'] || webCrypto['Subtle']);\r\n\r\nexport const UNSUPPORTED_ALGORITHM = 'Unsupported algorithm name specified! Supported algorithms: \"HS256\", \"HS384\", \"HS512\", \"RS256\", \"RS384\", \"RS512\" and \"none\".';\r\nexport const ILLEGAL_ARGUMENT = 'Illegal argument specified!';\r\n\r\n\r\n/**\r\n * Pako 1.0.6 has 'from' property which is not included in current version of typeDef @types/pako@1.0.0\r\n *\r\n * @hidden\r\n */\r\ndeclare namespace Pako {\r\n    export interface DeflateOptions {\r\n        raw?: boolean;\r\n        from?: string;\r\n        to?: string;\r\n    }\r\n\r\n    export interface InflateOptions {\r\n        raw?: boolean;\r\n        from?: string;\r\n        to?: string;\r\n    }\r\n}\r\n\r\n/**\r\n * Class for creating a JwtSplit object with three parts of JWT Token as strings\r\n *\r\n * @class  JwtSplit\r\n */\r\nexport class JwtSplit {\r\n    /**\r\n     * Header (first) part of JWT Token\r\n     *\r\n     * @name  header\r\n     * @type {string}\r\n     */\r\n    header: string;\r\n\r\n    /**\r\n     * Payload (second) part of JWT Token\r\n     *\r\n     * @name  payload\r\n     * @type {string}\r\n     */\r\n    payload: string;\r\n\r\n    /**\r\n     * Signature (third) part of JWT Token\r\n     *\r\n     * @name  signature\r\n     * @type {string}\r\n     */\r\n    signature: string;\r\n\r\n    constructor(str: string) {\r\n        if (typeof str !== 'string') {\r\n            throw new Error(ILLEGAL_ARGUMENT);\r\n        }\r\n\r\n        const jwtArr = str.split('.');\r\n        if (jwtArr.length !== 3) {\r\n            throw new Error(ILLEGAL_ARGUMENT);\r\n        }\r\n\r\n        const [header, payload, signature] = jwtArr;\r\n        this.header = header;\r\n        this.payload = payload;\r\n        this.signature = signature;\r\n    }\r\n\r\n    public toString(): string {\r\n        return this.header + '.' + this.payload + '.' + this.signature\r\n    }\r\n}\r\n\r\n/** JwtPart interface basically object type definition used as a placeholder */\r\ninterface JwtPart {\r\n    [key: string]: any\r\n}\r\n\r\n/**\r\n * Class for creating a JwtDecode object with three parts of JWT Token, header and payload decoded and parsed, signature in initial form\r\n *\r\n * @class  JwtDecode\r\n */\r\nexport class JwtDecode {\r\n    /**\r\n     * Header (first) part of JWT Token\r\n     *\r\n     * @name  header\r\n     * @type {JwtPart}\r\n     */\r\n    public header: JwtPart = {};\r\n\r\n    /**\r\n     * Payload (second) part of JWT Token\r\n     *\r\n     * @name  payload\r\n     * @type {JwtPart}\r\n     */\r\n    public payload: JwtPart = {};\r\n\r\n    /**\r\n     * Signature (third) part of JWT Token\r\n     *\r\n     * @name  signature\r\n     * @type {string}\r\n     */\r\n    public signature: string = '';\r\n\r\n    constructor(str: string) {\r\n        if (typeof str !== 'string') {\r\n            throw new Error(ILLEGAL_ARGUMENT);\r\n        }\r\n        const jwtObj: JwtSplit = jwtSplit(str);\r\n        if (jwtObj) {\r\n            this.header = jwtObj.header ? s2J(bu2s(jwtObj.header)) : {};\r\n            this.payload = jwtObj.payload ? (isGzip(this.header) ? s2J(zbu2s(jwtObj.payload)) : s2J(bu2s(jwtObj.payload))) : {};\r\n            this.signature = jwtObj.signature || '';\r\n        }\r\n    }\r\n\r\n    public toString(): string {\r\n        return s2bu(JSON.stringify(this.header)) + '.' + (isGzip(this.header) ? s2zbu(JSON.stringify(this.payload)) : s2bu(JSON.stringify(this.payload))) + '.' + this.signature\r\n    }\r\n}\r\n/**\r\n * Converts string to base64 string\r\n *\r\n * @param {string} str - data string to convert\r\n *\r\n * @returns {string} decoded data string\r\n */\r\nexport function s2J(str: string): any {\r\n    try{\r\n        return JSON.parse(str);\r\n    } catch(e) {\r\n        throw new Error(ILLEGAL_ARGUMENT);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Converts string to base64 string\r\n *\r\n * @param {string} str - data string to convert\r\n *\r\n * @returns {string} decoded data string\r\n */\r\nexport function b2s(str: string): string {\r\n    try{\r\n        if(typeof window === 'object' && typeof window.atob === 'function') {\r\n            return window.atob(str);\r\n        } else if(typeof Buffer !== 'undefined') {\r\n            return new Buffer(str, 'base64').toString('binary')\r\n        } else throw new Error(ILLEGAL_ARGUMENT);\r\n    } catch(e) {\r\n        throw new Error(e);\r\n    }\r\n}\r\n\r\n/**\r\n * Converts base64 string to base64url string\r\n *\r\n * @param {string} str - data string to convert\r\n *\r\n * @returns {string} base64url string\r\n */\r\nexport function b2bu(str: string): string {\r\n    if ((typeof str !== 'string') || (str.length % 4 !== 0)) {\r\n        throw new Error(ILLEGAL_ARGUMENT);\r\n    }\r\n\r\n    return str\r\n        .replace(/\\+/g, '-')\r\n        .replace(/\\//g, '_')\r\n        .replace(/=/g, '');\r\n}\r\n\r\n/**\r\n *\r\n * Converts base64url string to base64 string\r\n *\r\n * @param {string} str - data string to convert\r\n *\r\n * @returns {string} base64 string\r\n */\r\nexport function bu2b(str: string): string {\r\n    if ((typeof str !== 'string') || (str.length % 4 === 1)) {\r\n        throw new Error(ILLEGAL_ARGUMENT);\r\n    }\r\n\r\n    for (; (str.length % 4 !== 0);) {\r\n        str += '=';\r\n    }\r\n    return str\r\n        .replace(/\\-/g, '+')\r\n        .replace(/_/g, '/');\r\n}\r\n\r\n/**\r\n * Converts base64url string to string\r\n *\r\n * @param {string} str - base64url string to convert\r\n *\r\n * @returns {string} decoded data string\r\n */\r\nexport function bu2s(str: string): string {\r\n    return b2s(bu2b(str));\r\n}\r\n\r\n/**\r\n * Check if header has zip property (and it is equal to 'GZIP', ignorecase)\r\n *\r\n * @param {string} header - object to check\r\n *\r\n * @returns {boolean} does it have gzip in zip property\r\n */\r\nexport function isGzip(header: JwtPart): boolean {\r\n    return typeof header === 'object' && typeof header.zip === 'string' && header.zip.toUpperCase() === 'GZIP'\r\n}\r\n\r\n/**\r\n * Decode jwtToken header and payload\r\n *\r\n * @param {string} str - data string to decode\r\n *\r\n * @returns {JwtDecode} object with decoded header and body, and signature untouched\r\n */\r\nexport function jwtDecode(str: string): JwtDecode {\r\n    return new JwtDecode(str);\r\n}\r\n\r\n/**\r\n * Split jwtToken into object {header, payload, signature}\r\n *\r\n * @param {string} str - data string to split\r\n *\r\n * @returns {JwtSplit} jwt split object of three strings\r\n */\r\nexport function jwtSplit(str: string): JwtSplit {\r\n    return new JwtSplit(str);\r\n}\r\n\r\n/**\r\n * Converts base64 string to string\r\n *\r\n * @param {string} str - data string to convert\r\n *\r\n * @returns {string} base64 string\r\n */\r\nexport function s2b(str: string): string {\r\n    try{\r\n        if(typeof window === 'object' && typeof window.atob === 'function') {\r\n            return window.btoa(str);\r\n        } else if(typeof Buffer !== 'undefined') {\r\n            return new Buffer(str).toString('base64');\r\n        } else throw new Error(ILLEGAL_ARGUMENT);\r\n    } catch(e) {\r\n        throw new Error(e);\r\n    }\r\n}\r\n\r\n/**\r\n * Converts string to base64url string\r\n *\r\n * @param {string} str - data string to convert\r\n *\r\n * @returns {string} base64url string\r\n */\r\nexport function s2bu(str: string): string {\r\n    return b2bu(s2b(str));\r\n}\r\n\r\n/**\r\n * Gzip and encode data string to base64url string\r\n *\r\n * @param {string} str - data string to encode\r\n *\r\n * @returns {string} base64url string\r\n */\r\nexport function s2zbu(str: string): string {\r\n    return s2bu(zip(str));\r\n}\r\n\r\n/**\r\n * Converts from gzip data string to string\r\n *\r\n * @param {string} str - data string to convert\r\n *\r\n * @returns {string} decoded data string\r\n */\r\nexport function unzip(str: string): string {\r\n    if (typeof str !== 'string') {\r\n        throw new Error(ILLEGAL_ARGUMENT);\r\n    }\r\n\r\n    return pako.inflate(str, {\r\n        raw: false,\r\n        from: 'string',\r\n        to: 'string'\r\n    } as Pako.InflateOptions & { to: 'string' });\r\n}\r\n\r\n/**\r\n * Decode from base64url and unzip data string\r\n *\r\n * @param {string} str - data string to decode\r\n *\r\n * @returns {string} decoded data string\r\n */\r\nexport function zbu2s(str: string): string {\r\n    return unzip(bu2s(str));\r\n}\r\n\r\n/**\r\n * Converts string to gzip data string\r\n *\r\n * @param {string} str - data string to convert\r\n *\r\n * @returns {string} gzip data string\r\n */\r\nexport function zip(str: string): string {\r\n    if (typeof str !== 'string') {\r\n        throw new Error(ILLEGAL_ARGUMENT);\r\n    }\r\n\r\n    return pako.deflate(str, {\r\n        raw: false,\r\n        from: 'string',\r\n        to: 'string'\r\n    } as Pako.DeflateOptions & { to: 'string' });\r\n}\r\n\r\n/**\r\n * Converts string to ArrayBuffer\r\n *\r\n * @param {string} str - data string to convert\r\n *\r\n * @returns {ArrayBuffer | Uint8Array} charCode ArrayBuffer\r\n */\r\nfunction s2AB(str: string): ArrayBuffer | Uint8Array {\r\n    const buff = new Uint8Array(str.length);\r\n    for (let i = 0; i < str.length; i++) buff[i] = str.charCodeAt(i);\r\n    return buff;\r\n}\r\n\r\n/**\r\n * Converts ArrayBuffer to string\r\n *\r\n * @param {ArrayBuffer | Uint8Array} buff - charCode ArrayBuffer to convert\r\n *\r\n * @returns {string} data string\r\n */\r\nfunction AB2s(buff: ArrayBuffer | Uint8Array): string {\r\n    if (buff instanceof ArrayBuffer) buff = new Uint8Array(buff);\r\n    return String.fromCharCode.apply(String, buff);\r\n}\r\n\r\n/*\r\nexport function algHSsign(bits: number) {\r\n    return function sign(thing: string, secret: string): string {\r\n        const hmac = createHmac('sha' + bits, secret);\r\n        return b2bu(hmac.update(thing).digest('base64'));\r\n    }\r\n}\r\n\r\nexport function algHSverify(bits: number) {\r\n    return function verify(thing: string, signature: string, secret: string): boolean {\r\n        return signature === algHSsign(bits)(thing, secret);\r\n    }\r\n}\r\n\r\nexport function algRSsign(bits: number) {\r\n    return function sign(thing: string, privateKey: string): string {\r\n        const rsaSign = createSign('RSA-SHA' + bits);\r\n        return b2bu(rsaSign.update(thing).sign(privateKey, 'base64'));\r\n    }\r\n}\r\n\r\nexport function algRSverify(bits: number) {\r\n    return function verify(thing: string, signature: string, publicKey: string): boolean {\r\n        signature = bu2b(signature);\r\n        const rsaVerify = createVerify('RSA-SHA' + bits);\r\n        rsaVerify.update(thing);\r\n        return rsaVerify.verify(publicKey, signature, 'base64');\r\n    }\r\n}*/\r\n\r\n/**\r\n * Async function inspired by createHmac in crypto (used WebCrypto Api supported by most browsers)\r\n *\r\n */\r\n\r\nexport async function createHmac(name: string, secret: string): Promise<any> {\r\n    if (webCryptoSubtle) {\r\n        const keyData = s2AB(secret);\r\n        return await webCryptoSubtle.importKey(\r\n            'raw',\r\n            keyData,\r\n            { name: 'HMAC', hash: { name: name } },\r\n            true,\r\n            ['sign']\r\n        ).then(key => {\r\n            return {\r\n                _key: key,\r\n                update: async function (thing): Promise<ArrayBuffer> {\r\n                    return await webCryptoSubtle.sign(\r\n                        'HMAC',\r\n                        key,\r\n                        s2AB(thing)\r\n                    )\r\n                }\r\n            }\r\n        })\r\n    } else {\r\n        return !!crypto && crypto.createHmac ? Promise.resolve(crypto.createHmac(name.replace('SHA-', 'sha'), secret)) : Promise.reject(webCrypto);\r\n    }\r\n}\r\n\r\n/**\r\n * Algorithm HMAC sign generator\r\n *\r\n */\r\nexport function algHSsign(bits: number) {\r\n    /**\r\n     * Algorithm HMAC signer\r\n     *\r\n     */\r\n    return async function sign(thing: string, secret: string): Promise<string> {\r\n        const hmac = await createHmac('SHA-' + bits, secret);\r\n        return Promise.resolve(webCryptoSubtle ? s2bu(AB2s(hmac && await hmac.update(thing))) : b2bu(hmac && hmac.update(thing).digest('base64')));\r\n    }\r\n}\r\n\r\n/**\r\n * Algorithm HMAC verify generator\r\n *\r\n */\r\nexport function algHSverify(bits: number) {\r\n    /**\r\n     * Algorithm HMAC verifier\r\n     *\r\n     */\r\n    return async function verify(thing: string, signature: string, secret: string): Promise<boolean> {\r\n        return await algHSsign(bits)(thing, secret) === signature;\r\n    }\r\n}\r\n\r\n/*export function algRSsign(bits: number) {\r\n    return function sign(thing: string, privateKey: string): string {\r\n        const rsaSign = crypto.createSign('RSA-SHA' + bits);\r\n        return b2bu(rsaSign.update(thing).sign(privateKey, 'base64'));\r\n    }\r\n}\r\n\r\nexport function algRSverify(bits: number) {\r\n    return function verify(thing: string, signature: string, publicKey: string): boolean {\r\n        signature = bu2b(signature);\r\n        const rsaVerify = crypto.createVerify('RSA-SHA' + bits);\r\n        rsaVerify.update(thing);\r\n        return rsaVerify.verify(publicKey, signature, 'base64');\r\n    }\r\n}*/\r\n\r\n/**\r\n * Universal algorithm verifier\r\n *\r\n */\r\nexport async function algVerify(algorithm: string, thing: string, signature: string, secret: string): Promise<boolean> {\r\n    if (typeof algorithm !== 'string' || algorithm.length < 4) {\r\n        throw new Error(UNSUPPORTED_ALGORITHM);\r\n    }\r\n    const algo = algorithm.toLowerCase();\r\n\r\n    if (algo === 'none') {\r\n        return signature === '';\r\n    }\r\n\r\n    const type = algo.slice(0, 2), bits = parseInt(algo.slice(2));\r\n    if (isNaN(bits) || ([256, 384, 512].indexOf(bits) < 0)) {\r\n        throw new Error(UNSUPPORTED_ALGORITHM);\r\n    }\r\n\r\n    switch (type) {\r\n        //case 'rs':\r\n            //return await algRSverify(bits)(thing, signature, secret);\r\n        case 'hs':\r\n            return await algHSverify(bits)(thing, signature, secret);\r\n        default:\r\n            throw new Error(UNSUPPORTED_ALGORITHM);\r\n    }\r\n}\r\n\r\n/**\r\n * Universal algorithm signer\r\n *\r\n */\r\nexport async function algSign(algorithm: string, thing: string, secret: string): Promise<string> {\r\n    if (typeof algorithm !== 'string' || algorithm.length < 4) {\r\n        throw new Error(UNSUPPORTED_ALGORITHM);\r\n    }\r\n    const algo = algorithm.toLowerCase();\r\n\r\n    if (algo === 'none') {\r\n        return '';\r\n    }\r\n\r\n    const type = algo.slice(0, 2), bits = parseInt(algo.slice(2));\r\n    if (isNaN(bits) || ([256, 384, 512].indexOf(bits) < 0)) {\r\n        throw new Error(UNSUPPORTED_ALGORITHM);\r\n    }\r\n\r\n    switch (type) {\r\n        //case 'rs':\r\n            //return await algRSsign(bits)(thing, secret);\r\n        case 'hs':\r\n            return await algHSsign(bits)(thing, secret);\r\n        default:\r\n            throw new Error(UNSUPPORTED_ALGORITHM);\r\n    }\r\n}\r\n\r\nexport async function jwtVerify(jwtStr: string, secret: string): Promise<boolean> {\r\n    const jwt = jwtSplit(jwtStr),\r\n        header = s2J(bu2s(jwt.header)),\r\n        thing = jwt.header + '.' + jwt.payload;\r\n    return await algVerify(header.alg, thing, jwt.signature, secret);\r\n}\r\n\r\nexport async function jwtSign(jwtStr: string, secret: string): Promise<string> {\r\n    const jwt = jwtSplit(jwtStr),\r\n        header = s2J(bu2s(jwt.header)),\r\n        thing = jwt.header + '.' + jwt.payload;\r\n    return await algSign(header.alg, thing, secret);\r\n}\r\n\r\nexport async function resignJwt(jwtStr: string, secret: string): Promise<string> {\r\n    const jwt = jwtSplit(jwtStr),\r\n        header = s2J(bu2s(jwt.header)),\r\n        thing = jwt.header + '.' + jwt.payload;\r\n    return thing + '.' + await algSign(header.alg, thing, secret);\r\n}\r\n\r\n/**\r\n * Used for testing only\r\n *\r\n * @hidden\r\n */\r\nexport function cryptoType(): string {\r\n    return crypto ? crypto['type'] || 'crypto-node' : 'undefined';\r\n}\r\n\r\nconst jwsJsDecode = {\r\n    JwtDecode,\r\n    JwtSplit,\r\n    b2bu,\r\n    b2s,\r\n    bu2b,\r\n    bu2s,\r\n    isGzip,\r\n    jwtDecode,\r\n    jwtSplit,\r\n    s2b,\r\n    s2bu,\r\n    s2zbu,\r\n    unzip,\r\n    zbu2s,\r\n    zip,\r\n    algHSsign,\r\n    algHSverify,\r\n    //algRSsign,\r\n    //algRSverify,\r\n    algVerify,\r\n    algSign,\r\n    jwtVerify,\r\n    jwtSign,\r\n    resignJwt,\r\n    cryptoType\r\n};\r\n\r\nexport default jwsJsDecode;\r\n"],"names":[],"mappings":"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"}